{"refs":{"refs/heads/master":"b8da78e900882f7f8dc76c14cb7351b2a2b8e8f2","refs/pull/3/head":"01b7cfe4032f145d6d46018f03b2a04dff4c4998","refs/pull/3/merge":"2042b791bbc70a5ca7d4b7fe373bb01804727e6f","refs/pull/4/head":"ffe52058d3fdebc31db5f386ffc3204a823c161d","refs/pull/4/merge":"5f40e6104b84dfe7f2200b7c3d350c8a526e2579","refs/pull/5/head":"e3dc25871f7b6a8f44834fa687b2f886f9efc66f","refs/pull/5/merge":"27b72143c33890e2603ad296d95013d8c819c191","refs/pull/8/head":"60e99e726535d5291e9dcc65d5285d25c0f56dc0","refs/pull/8/merge":"e48e4a49bf00043a4cb1969fff58f1e1950cd78f","refs/tags/0.1.0":"8dd55f981a031edd32b1973ea886c9b9e4189d08","refs/tags/0.1.1":"0794a5cdc823d7c357646775bbb0ff0b72386e0d","refs/tags/0.1.5":"3d7af12570107f82820824846ffa47ab4d8fc922","refs/tags/0.2.0":"6a49fe7f8f6fcc6ae13e0c0076530ea1d289fd93","refs/tags/0.2.1":"6169aaa30d05b38d8e69273a181789442c38b1c1","refs/tags/0.3.0":"b8da78e900882f7f8dc76c14cb7351b2a2b8e8f2"},"objects":{"e48e4a49bf00043a4cb1969fff58f1e1950cd78f":{"type":"commit","body":{"tree":"b9d9a184cdea67619f3607fc29ec0009a4b5142d","parents":["b8da78e900882f7f8dc76c14cb7351b2a2b8e8f2","60e99e726535d5291e9dcc65d5285d25c0f56dc0"],"author":"Chakrit Wichian <buhtig@chakrit.net> 1377069756 -0700","committer":"Chakrit Wichian <buhtig@chakrit.net> 1377069756 -0700","message":"Merge 60e99e726535d5291e9dcc65d5285d25c0f56dc0 into b8da78e900882f7f8dc76c14cb7351b2a2b8e8f2\n"}},"60e99e726535d5291e9dcc65d5285d25c0f56dc0":{"type":"commit","body":{"tree":"b9d9a184cdea67619f3607fc29ec0009a4b5142d","parents":["f0cdca441e1ea245499afc5c93e157345c225071"],"author":"Chakrit Wichian <chakrit@oozou.com> 1377069690 +0700","committer":"Chakrit Wichian <chakrit@oozou.com> 1377069738 +0700","message":"Add extension type info to README + some typo fix.\n"}},"f0cdca441e1ea245499afc5c93e157345c225071":{"type":"commit","body":{"tree":"2e96107461e0ae3a2c468b462911b9ebf5981066","parents":["73d158c6f2d3c5bdfe4c629a7e04b20927abfccf"],"author":"Chakrit Wichian <chakrit@oozou.com> 1377069316 +0700","committer":"Chakrit Wichian <chakrit@oozou.com> 1377069321 +0700","message":"Fix broken link in README\n"}},"73d158c6f2d3c5bdfe4c629a7e04b20927abfccf":{"type":"commit","body":{"tree":"804bf23ae67d25986e6e24f47fd697b11fc0602d","parents":["82dfa9eee52b70b35f09543a0ef3e1a8193ee012"],"author":"Chakrit Wichian <chakrit@oozou.com> 1377069208 +0700","committer":"Chakrit Wichian <chakrit@oozou.com> 1377069208 +0700","message":"Version follows msgpack-js\n"}},"82dfa9eee52b70b35f09543a0ef3e1a8193ee012":{"type":"commit","body":{"tree":"892bd68b4e95606b455f5ecbf3d44cfa49d4c8cd","parents":["128e53d78d456c94d80cfb7d8143b5eb1d29e650"],"author":"Chakrit Wichian <chakrit@oozou.com> 1377069083 +0700","committer":"Chakrit Wichian <chakrit@oozou.com> 1377069083 +0700","message":"Repackaging into a separate npm module.\n"}},"128e53d78d456c94d80cfb7d8143b5eb1d29e650":{"type":"commit","body":{"tree":"238443d8beae512a0a70480fe7d422c2aecdf02e","parents":["b8da78e900882f7f8dc76c14cb7351b2a2b8e8f2"],"author":"Chakrit Wichian <chakrit@oozou.com> 1376467868 +0700","committer":"Chakrit Wichian <chakrit@oozou.com> 1376467872 +0700","message":"MessagePack Proposal v5 with explicit string type.\n\nReference: https://gist.github.com/frsyuki/5432559#types-extension-type\n\n* Reorder decoder types detection code so it aligns with mapping tables in the specs.\n* Changed how `undefined` are handled, uses the `fixext 1` extension type instead.\n* Removed old `raw`-related things.\n* Added support for `str` type family decoded to node string.\n* Added support for `bin` type family decoded to node Buffer.\n* Added support for `ext` and `fixext` type family decoded to a [type, Buffer] tuple.\n  * Exception for `fixext 1` which is just 1-byte long so a simple [type, value] is\n    returned instead.\n* TODO: There is no test for the `ext` and `fixext` since there is no way/need in JS to\n  specify and encode \"extension\" type. Would be good to have tests on decoding part though\n  since other languages/implementation may have made use of them.\n"}},"b8da78e900882f7f8dc76c14cb7351b2a2b8e8f2":{"type":"commit","body":{"tree":"9e50f096df651715f5874d946e0c033339fc527f","parents":["a25a12c5b250119b73b39913b0f5172bf912fd3a"],"author":"Tim Caswell <tim@creationix.com> 1374506755 -0500","committer":"Tim Caswell <tim@creationix.com> 1374506755 -0500","message":"Bump version to 0.3.0\n"}},"6169aaa30d05b38d8e69273a181789442c38b1c1":{"type":"commit","body":{"tree":"7bda302b13bc4e1f31f8b03c5dea6aac5f3d242a","parents":["6a49fe7f8f6fcc6ae13e0c0076530ea1d289fd93"],"author":"Tim Caswell <tim@creationix.com> 1369087536 -0500","committer":"Tim Caswell <tim@creationix.com> 1369087536 -0500","message":"Fix tests for browser and bump version to 0.2.1\n"}},"6a49fe7f8f6fcc6ae13e0c0076530ea1d289fd93":{"type":"commit","body":{"tree":"430185ddd7e17238d43f6720ba9e83696f6dcffe","parents":["07221df1e09e6f2416ae23c5ce375a66db600311"],"author":"Tim Caswell <tim@creationix.com> 1369084608 -0500","committer":"Tim Caswell <tim@creationix.com> 1369084608 -0500","message":"Fix syntax error in package.json\n"}},"3d7af12570107f82820824846ffa47ab4d8fc922":{"type":"commit","body":{"tree":"44dc81302d7f4cc7173ba681aad2b110e8851f80","parents":["ea06d611549f8a09f172a774a4dbd8f75fcabc7b"],"author":"Tim Caswell <tim@creationix.com> 1361827618 -0600","committer":"Tim Caswell <tim@creationix.com> 1361827618 -0600","message":"Bump version to 0.1.5\n"}},"0794a5cdc823d7c357646775bbb0ff0b72386e0d":{"type":"commit","body":{"tree":"b88a60a16b93962f9b1f9cb89d435ea40df67dc1","parents":["6b0b07301325c92d6e54d9ae4ae636ae14e2c64d"],"author":"Tim Caswell <tim@creationix.com> 1341445176 -0500","committer":"Tim Caswell <tim@creationix.com> 1341445176 -0500","message":"Bump version to 0.1.1\n"}},"8dd55f981a031edd32b1973ea886c9b9e4189d08":{"type":"commit","body":{"tree":"9677ebacd5d1450706dd109dc891093903f058a1","parents":["375f64944e32a89db643a03375095b8a8ad74b8a"],"author":"Tim Caswell <tim@creationix.com> 1328908953 -0600","committer":"Tim Caswell <tim@creationix.com> 1328908953 -0600","message":"Update readme and publish on npm as msgpack-js\n"}},"a25a12c5b250119b73b39913b0f5172bf912fd3a":{"type":"commit","body":{"tree":"205900fa32640820ceab3e40fa8d1a2698a1cdd1","parents":["7c7fce3da0a28be0b9d636b2dccae3cb3d9adcef","e3dc25871f7b6a8f44834fa687b2f886f9efc66f"],"author":"Tim Caswell <tim@creationix.com> 1374506699 -0700","committer":"Tim Caswell <tim@creationix.com> 1374506699 -0700","message":"Merge pull request #5 from dominictarr/master\n\nbehave more like JSON.stringify"}},"27b72143c33890e2603ad296d95013d8c819c191":{"type":"commit","body":{"tree":"205900fa32640820ceab3e40fa8d1a2698a1cdd1","parents":["7c7fce3da0a28be0b9d636b2dccae3cb3d9adcef","e3dc25871f7b6a8f44834fa687b2f886f9efc66f"],"author":"Dominic Tarr <dominic.tarr@gmail.com> 1374493984 -0700","committer":"Dominic Tarr <dominic.tarr@gmail.com> 1374493984 -0700","message":"Merge e3dc25871f7b6a8f44834fa687b2f886f9efc66f into 7c7fce3da0a28be0b9d636b2dccae3cb3d9adcef\n"}},"e3dc25871f7b6a8f44834fa687b2f886f9efc66f":{"type":"commit","body":{"tree":"205900fa32640820ceab3e40fa8d1a2698a1cdd1","parents":["e48e951fddc47c41543949e6c0330d5e56c2a83a","9b0b0c321d1de5b2ed8197319eaef1f4eaa76479"],"author":"Dominic Tarr <dominic.tarr@gmail.com> 1374493153 +0100","committer":"Dominic Tarr <dominic.tarr@gmail.com> 1374493153 +0100","message":"use tape and testling\n"}},"e48e951fddc47c41543949e6c0330d5e56c2a83a":{"type":"commit","body":{"tree":"f082a5f07415747dc5f4fe3cbd14606fdf7833a7","parents":["87c37039c30acb9d1919842cc14093da19faa86b"],"author":"Dominic Tarr <dominic.tarr@gmail.com> 1374492770 +0100","committer":"Dominic Tarr <dominic.tarr@gmail.com> 1374492770 +0100","message":"fix toJSON and handle functions correctly\n"}},"87c37039c30acb9d1919842cc14093da19faa86b":{"type":"commit","body":{"tree":"dca3c76b55d519c9a60053362421abf1dfc14cc8","parents":["7c7fce3da0a28be0b9d636b2dccae3cb3d9adcef"],"author":"Dominic Tarr <dominic.tarr@gmail.com> 1374492748 +0100","committer":"Dominic Tarr <dominic.tarr@gmail.com> 1374492748 +0100","message":"test that toJSON works, and that functions are handled like JSON does\n"}},"7c7fce3da0a28be0b9d636b2dccae3cb3d9adcef":{"type":"commit","body":{"tree":"22103d1a808335d9b12766ad611773a59af16eeb","parents":["f10f2f21c208c3ff25f5321befc95259ec486429"],"author":"Tim Caswell <tim@creationix.com> 1369155197 -0500","committer":"Tim Caswell <tim@creationix.com> 1369155207 -0500","message":"Add node 0.11.x testing\n"}},"f10f2f21c208c3ff25f5321befc95259ec486429":{"type":"commit","body":{"tree":"42a0b07edda69c054bb24101493e436483fa5e62","parents":["a700469cfb04536ea1827139f7e32a5dad0a1736"],"author":"Tim Caswell <tim@creationix.com> 1369087913 -0500","committer":"Tim Caswell <tim@creationix.com> 1369087913 -0500","message":"Update README.markdown"}},"a700469cfb04536ea1827139f7e32a5dad0a1736":{"type":"commit","body":{"tree":"b73b5df0fd85216f583b58f5fae6c5d068134a15","parents":["6169aaa30d05b38d8e69273a181789442c38b1c1"],"author":"Tim Caswell <tim@creationix.com> 1369087879 -0500","committer":"Tim Caswell <tim@creationix.com> 1369087879 -0500","message":"Add node 0.10.x to travis suite\n"}},"07221df1e09e6f2416ae23c5ce375a66db600311":{"type":"commit","body":{"tree":"7ed3c4cf367cfbf19f23f16fb3752987aeb74bcf","parents":["bc492dd35fde1f131933ae9baf5ef0281c4d7869"],"author":"Tim Caswell <tim@creationix.com> 1369084571 -0400","committer":"Tim Caswell <tim@creationix.com> 1369084571 -0400","message":"Update README.markdown"}},"bc492dd35fde1f131933ae9baf5ef0281c4d7869":{"type":"commit","body":{"tree":"be68618a463ad94ec7dff7a1b8c9839b920e00d7","parents":["3d7af12570107f82820824846ffa47ab4d8fc922"],"author":"Tim Caswell <tim@creationix.com> 1369084396 -0500","committer":"Tim Caswell <tim@creationix.com> 1369084396 -0500","message":"Convert to use bops so it works in the browser too\n"}},"5f40e6104b84dfe7f2200b7c3d350c8a526e2579":{"type":"commit","body":{"tree":"f61ad382d7ab165be2244e8087beb2dee97acc23","parents":["ea06d611549f8a09f172a774a4dbd8f75fcabc7b","ffe52058d3fdebc31db5f386ffc3204a823c161d"],"author":"tarruda <tpadilha84@gmail.com> 1354743938 -0800","committer":"tarruda <tpadilha84@gmail.com> 1354743938 -0800","message":"Merge ffe52058d3fdebc31db5f386ffc3204a823c161d into ea06d611549f8a09f172a774a4dbd8f75fcabc7b\n"}},"ffe52058d3fdebc31db5f386ffc3204a823c161d":{"type":"commit","body":{"tree":"f61ad382d7ab165be2244e8087beb2dee97acc23","parents":["ea06d611549f8a09f172a774a4dbd8f75fcabc7b"],"author":"Thiago de Arruda <tpadilha84@gmail.com> 1354743147 -0300","committer":"Thiago de Arruda <tpadilha84@gmail.com> 1354743147 -0300","message":"Fixed so it is possible to decode streams\n\n- Exported the 'Decoder' class.\n- Added 'bytesRemaining' property to decoder class.\n- Added a wrapper method for 'Decoder.parse' in order to keep the\n  'bytesRemaining' from updating on parse failure.\n"}},"ea06d611549f8a09f172a774a4dbd8f75fcabc7b":{"type":"commit","body":{"tree":"3f9ff5bb235686bf4b003887f32363c8446b475b","parents":["fb7cfd6f745c372c46bb99a141164ede52a8f3f5"],"author":"Tim Caswell <tim@creationix.com> 1350918605 -0400","committer":"Tim Caswell <tim@creationix.com> 1350918605 -0400","message":"Don't assume the test is running in a tty\n"}},"fb7cfd6f745c372c46bb99a141164ede52a8f3f5":{"type":"commit","body":{"tree":"8fccfc79aca3ef169a08e19e8280399d838c47db","parents":["7297fcd223ac0ec50dc2fc5ce1cfe14f10976d62"],"author":"Tim Caswell <tim@creationix.com> 1344008547 -0500","committer":"Tim Caswell <tim@creationix.com> 1344008547 -0500","message":"Set node versions to test on travis ci\n"}},"7297fcd223ac0ec50dc2fc5ce1cfe14f10976d62":{"type":"commit","body":{"tree":"65e63323cf2f03e952cd3123ae60f00ac6520a7b","parents":["6a0183c0450a32c2d53f6b93542bed1220fe44cf"],"author":"Tim Caswell <tim@creationix.com> 1344008293 -0500","committer":"Tim Caswell <tim@creationix.com> 1344008293 -0500","message":"Update README.markdown"}},"6a0183c0450a32c2d53f6b93542bed1220fe44cf":{"type":"commit","body":{"tree":"be30f82be95278680465ac01ca2d9983c0057514","parents":["f62d4adcecca3717e06b67a9e52468149c000b81"],"author":"Tim Caswell <tim@creationix.com> 1344008189 -0500","committer":"Tim Caswell <tim@creationix.com> 1344008189 -0500","message":"Add travis ci integration\n"}},"f62d4adcecca3717e06b67a9e52468149c000b81":{"type":"commit","body":{"tree":"3a142438464a5ca71228a4a6ee9455e610e7a76c","parents":["0794a5cdc823d7c357646775bbb0ff0b72386e0d","01b7cfe4032f145d6d46018f03b2a04dff4c4998"],"author":"Tim Caswell <tim@creationix.com> 1342301253 -0700","committer":"Tim Caswell <tim@creationix.com> 1342301253 -0700","message":"Merge pull request #3 from chilts/patch-1\n\nFix the repo URL for msgpack-js"}},"2042b791bbc70a5ca7d4b7fe373bb01804727e6f":{"type":"commit","body":{"tree":"3a142438464a5ca71228a4a6ee9455e610e7a76c","parents":["0794a5cdc823d7c357646775bbb0ff0b72386e0d","01b7cfe4032f145d6d46018f03b2a04dff4c4998"],"author":"GitHub Merge Button <merge-button@github.com> 1342257924 -0700","committer":"GitHub Merge Button <merge-button@github.com> 1342257924 -0700","message":"Merge 01b7cfe4032f145d6d46018f03b2a04dff4c4998 into 0794a5cdc823d7c357646775bbb0ff0b72386e0d\n"}},"01b7cfe4032f145d6d46018f03b2a04dff4c4998":{"type":"commit","body":{"tree":"3a142438464a5ca71228a4a6ee9455e610e7a76c","parents":["0794a5cdc823d7c357646775bbb0ff0b72386e0d"],"author":"Andrew Chilton <andychilton@gmail.com> 1342257875 +1200","committer":"Andrew Chilton <andychilton@gmail.com> 1342257875 +1200","message":"Fix the repo URL for msgpack-js"}},"9b0b0c321d1de5b2ed8197319eaef1f4eaa76479":{"type":"commit","body":{"tree":"115c12e33556ee40a8574760b1e2a94489745d96","parents":["0794a5cdc823d7c357646775bbb0ff0b72386e0d"],"author":"Dominic Tarr <dominic.tarr@gmail.com> 1342226738 +1200","committer":"Dominic Tarr <dominic.tarr@gmail.com> 1342226738 +1200","message":"fix link from npmjs.org/#/msgpack-js and add enable `npm test`\n"}},"6b0b07301325c92d6e54d9ae4ae636ae14e2c64d":{"type":"commit","body":{"tree":"4fa3bdeaa2518e266d3b9d83e20134a0bf097735","parents":["e158cafb63f9f7f986a4117fc61854049b0c2e31"],"author":"Tim Caswell <tim@creationix.com> 1341437201 -0700","committer":"Tim Caswell <tim@creationix.com> 1341444905 -0500","message":"Increase speed 2x by using prototypes and ordering the switch statements differently\n"}},"e158cafb63f9f7f986a4117fc61854049b0c2e31":{"type":"commit","body":{"tree":"92e70e6cbcb1db23d1dfca660cc4b9962e6d9ba2","parents":["8ccc14e7ea3280cd089af584b073d00dcbeac425"],"author":"Tim Caswell <tim@creationix.com> 1340649682 -0500","committer":"Tim Caswell <tim@creationix.com> 1340649682 -0500","message":"Allow to run in node 0.8.x\n"}},"8ccc14e7ea3280cd089af584b073d00dcbeac425":{"type":"commit","body":{"tree":"fc6d8a556524b1dd9bd69c462951bb95c068b9ba","parents":["e1ffe83caa737d75fbc0812ebc8b339cec33b201"],"author":"Tim Caswell <tim@creationix.com> 1329848646 -0600","committer":"Tim Caswell <tim@creationix.com> 1329848646 -0600","message":"Update README.markdown"}},"e1ffe83caa737d75fbc0812ebc8b339cec33b201":{"type":"commit","body":{"tree":"7d58960fc86b932a7ba3f50b40f7b8eb02cc11c9","parents":["52c8a1ee1eadebab8dd7044976a134fcef548915"],"author":"Tim Caswell <tim@creationix.com> 1328910347 -0600","committer":"Tim Caswell <tim@creationix.com> 1328910347 -0600","message":"Clean up reporting of test suite\n"}},"52c8a1ee1eadebab8dd7044976a134fcef548915":{"type":"commit","body":{"tree":"1d416db5c8f7abbfd374dbb54b388295b9f3b650","parents":["8dd55f981a031edd32b1973ea886c9b9e4189d08"],"author":"Tim Caswell <tim@creationix.com> 1328909236 -0600","committer":"Tim Caswell <tim@creationix.com> 1328909236 -0600","message":"Add more number tests to the unit test\n"}},"375f64944e32a89db643a03375095b8a8ad74b8a":{"type":"commit","body":{"tree":"401bc02f77903c930c4b33e1d6f14d4ab9d49b2d","parents":["1e6feb3be0afe14deecd121d969d6c8d55adb2a0"],"author":"Tim Caswell <tim@creationix.com> 1328908546 -0600","committer":"Tim Caswell <tim@creationix.com> 1328908546 -0600","message":"Remote old file\n"}},"1e6feb3be0afe14deecd121d969d6c8d55adb2a0":{"type":"commit","body":{"tree":"63bbee422ea72742c439a049e39ec881ad8e3835","parents":["7a0ca9cec10b8a633dbe2fdb9c99ea2b25ec404b"],"author":"Tim Caswell <tim@creationix.com> 1328908516 -0600","committer":"Tim Caswell <tim@creationix.com> 1328908516 -0600","message":"Rewrite completely using new APIs in node 0.6.x\n"}},"7a0ca9cec10b8a633dbe2fdb9c99ea2b25ec404b":{"type":"commit","body":{"tree":"c5fc29477483e4647b2f4ea26d262b199e9cfbcb","parents":["ddc73956c3c5c51b272a7bec7dce00e91c2aa726"],"author":"Tim Caswell <tim@creationix.com> 1295377098 -0800","committer":"Tim Caswell <tim@creationix.com> 1295377098 -0800","message":"Worked on 2nd edition\n\nChange-Id: Ie8d0df87d9c3b8df9fe0a614b30bc7450748cae6\n"}},"ddc73956c3c5c51b272a7bec7dce00e91c2aa726":{"type":"commit","body":{"tree":"142c0c73beb24d51c006c0b2ec82d4837fef0ade","parents":["0061d4a8c3b0399d6a65711053d3c0d2e3738277"],"author":"Tim Caswell <tim@creationix.com> 1292279341 -0800","committer":"Tim Caswell <tim@creationix.com> 1292279341 -0800","message":"Update readme\n\nChange-Id: I41c2b8377178a3a9700963b912ab9bab61af4971\n"}},"0061d4a8c3b0399d6a65711053d3c0d2e3738277":{"type":"commit","body":{"tree":"62d1d508d302136ef86791df0c6350bb1420ac32","parents":["3807e21ce309b8232a5ba7b99d846c835e3260c1"],"author":"Tim Caswell <tim@creationix.com> 1292279126 -0800","committer":"Tim Caswell <tim@creationix.com> 1292279126 -0800","message":"Complete initial implementation\n\nChange-Id: Ia3b44cad653363a2c9332af12a7d5d30cdcced26\n"}},"3807e21ce309b8232a5ba7b99d846c835e3260c1":{"type":"commit","body":{"tree":"c634c2ddfbc448cba978ac31134b5624ae5e68c5","parents":["5471f4397a456b4287912982742baaf3475c5a73"],"author":"Tim Caswell <tim@creationix.com> 1292275966 -0800","committer":"Tim Caswell <tim@creationix.com> 1292275966 -0800","message":"Start on parser\n\nChange-Id: I7a00c6d52b0118b1335606063f7022fb6690de54\n"}},"5471f4397a456b4287912982742baaf3475c5a73":{"type":"commit","body":{"tree":"14942334faff6d3244082366ad8964664f8069f6","parents":["8e4f8b0e6b03098ac554175da6b18511612c6cb8"],"author":"Tim Caswell <tim@creationix.com> 1292067341 -0800","committer":"Tim Caswell <tim@creationix.com> 1292067341 -0800","message":"Add a readme\n\nChange-Id: I976679f0e459a99bd355500c4dadc8631e8c191d\n"}},"8e4f8b0e6b03098ac554175da6b18511612c6cb8":{"type":"commit","body":{"tree":"25da9a014fb1a6dc2749c6e004759e6cd380ad13","author":"Tim Caswell <tim.caswell@palm.com> 1292067173 -0800","committer":"Tim Caswell <tim.caswell@palm.com> 1292067173 -0800","message":"Initial commit\n\nChange-Id: Ic53e688b6b8c42525aedfcc93eef189a4ff118a8\n"}},"2e96107461e0ae3a2c468b462911b9ebf5981066":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"AUTHORS","hash":"018aa78d34cb1506698f979f181bebbc231916df"},{"mode":33188,"name":"README.markdown","hash":"5c3f107284d6e09c23c475add738f86c351ad837"},{"mode":33188,"name":"msgpack.js","hash":"82b56e0277afa2dfddd31bfe3dd9512d81ac76b4"},{"mode":33188,"name":"package.json","hash":"ace80691652d73441e2c5ff9e69c872ccad84c67"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"9e50f096df651715f5874d946e0c033339fc527f":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"README.markdown","hash":"931ccdfc11fb13eea3b97b0e464567157a25368b"},{"mode":33188,"name":"msgpack.js","hash":"751945205c169821dc77f30ed6b1c7db7b49b436"},{"mode":33188,"name":"package.json","hash":"1ceb7e8e4c2404f05f2c17e1ac73f0916bda03e6"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"dca3c76b55d519c9a60053362421abf1dfc14cc8":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"README.markdown","hash":"931ccdfc11fb13eea3b97b0e464567157a25368b"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"96cba8f7c0e8651660dec4edf36b29a9f6a5bf5f"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"22103d1a808335d9b12766ad611773a59af16eeb":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"README.markdown","hash":"931ccdfc11fb13eea3b97b0e464567157a25368b"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"96cba8f7c0e8651660dec4edf36b29a9f6a5bf5f"},{"mode":33188,"name":"test.js","hash":"c2f802ed497ac913fdc7e1bf76e5ec66ea4bb19f"}]},"7bda302b13bc4e1f31f8b03c5dea6aac5f3d242a":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"8a0472d5af516253ed72b278ceb46ee64d8606dd"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"96cba8f7c0e8651660dec4edf36b29a9f6a5bf5f"},{"mode":33188,"name":"test.js","hash":"c2f802ed497ac913fdc7e1bf76e5ec66ea4bb19f"}]},"430185ddd7e17238d43f6720ba9e83696f6dcffe":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"f8a10a88fc083f43083d0393062dfeddb9b32ae6"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"6c3391a11573e754ace624ac719df7af81b5ec27"},{"mode":33261,"name":"test.js","hash":"6c9ddafa9ad2b02682081328fe0aadf15002a778"}]},"3f9ff5bb235686bf4b003887f32363c8446b475b":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"e8757048063dc4c3d6af4401220ac23581f2c60c"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"85de88d3b7ea78dc2e81f7a182d947ab5cb83ca6"},{"mode":33261,"name":"test.js","hash":"6c9ddafa9ad2b02682081328fe0aadf15002a778"}]},"be30f82be95278680465ac01ca2d9983c0057514":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"48fe0cd67caa7dbfbefccd6a8718d1c5eefe41a7"},{"mode":33188,"name":"README.markdown","hash":"bae85dcb004c3b1023e0d5da461ddfd861246567"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"85de88d3b7ea78dc2e81f7a182d947ab5cb83ca6"},{"mode":33261,"name":"test.js","hash":"771cbb73f2c9242618472c8049402951674e839a"}]},"115c12e33556ee40a8574760b1e2a94489745d96":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"bae85dcb004c3b1023e0d5da461ddfd861246567"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"957a56ec96fd8c8f14d524bd63f09811575d8713"},{"mode":33188,"name":"test.js","hash":"eb579ea870af3232f018b87d601dad9d1dbf70bf"}]},"1d416db5c8f7abbfd374dbb54b388295b9f3b650":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"6d4ee24c360c599a71ab14e9f12c458ccce1e646"},{"mode":33188,"name":"msgpack.js","hash":"9108faf6b226321507525a699856b5d5ae427284"},{"mode":33188,"name":"package.json","hash":"ea0ab5cd2e170e0fc131f90ff08045b3c4183b1a"},{"mode":33188,"name":"test.js","hash":"08ddffdb3f3452488363db3803d8271eec7c8434"}]},"63bbee422ea72742c439a049e39ec881ad8e3835":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"33118490d518b8b3edbf926d1e35e4e5a3dd805e"},{"mode":33188,"name":"encode.js","hash":"97c67a6b28101e9a7660cc70f234bd4111176ba7"},{"mode":33188,"name":"msgpack.js","hash":"9108faf6b226321507525a699856b5d5ae427284"},{"mode":33188,"name":"test.js","hash":"8c49dcc4d3f942cf9e9ed48b70520b836bcc9075"}]},"c5fc29477483e4647b2f4ea26d262b199e9cfbcb":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"dc8861d41b011f15b91c5c78411eb5a49496fd7a"},{"mode":33188,"name":"encode.js","hash":"97c67a6b28101e9a7660cc70f234bd4111176ba7"},{"mode":33188,"name":"msgpack.js","hash":"84dee00b735c8ff6a54e75782bfeef42fb920cd0"},{"mode":33188,"name":"test.js","hash":"ed8ce267449a2e4a290db802af8d6ab6ea0ec545"},{"mode":33188,"name":"test2.js","hash":"9db607e208c033e0829488d0244ef114712b1d02"}]},"142c0c73beb24d51c006c0b2ec82d4837fef0ade":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"dc8861d41b011f15b91c5c78411eb5a49496fd7a"},{"mode":33188,"name":"msgpack.js","hash":"84dee00b735c8ff6a54e75782bfeef42fb920cd0"},{"mode":33188,"name":"test.js","hash":"ed8ce267449a2e4a290db802af8d6ab6ea0ec545"},{"mode":33188,"name":"test2.js","hash":"9db607e208c033e0829488d0244ef114712b1d02"}]},"c634c2ddfbc448cba978ac31134b5624ae5e68c5":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"9bd677f09102818ab70b198ac3de537a9821d892"},{"mode":33188,"name":"msgpack.js","hash":"04e54d494b8d298440279438065e25bcce24059e"},{"mode":33188,"name":"test.js","hash":"fcc051343e889487e9c5a8128c56645c079d1798"}]},"14942334faff6d3244082366ad8964664f8069f6":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"9bd677f09102818ab70b198ac3de537a9821d892"},{"mode":33188,"name":"convert.js","hash":"95e1e0c5c4c16cce6589d4dc6d31de7c3ee112fc"}]},"25da9a014fb1a6dc2749c6e004759e6cd380ad13":{"type":"tree","body":[{"mode":33188,"name":"convert.js","hash":"95e1e0c5c4c16cce6589d4dc6d31de7c3ee112fc"}]},"8f4f27933b8e075c612260b90e40f2bd903eb403":{"type":"blob","body":"language: node_js\nnode_js:\n  - 0.11\n  - 0.10\n  - 0.8\n  - 0.6\nscript: node test.js\n"},"018aa78d34cb1506698f979f181bebbc231916df":{"type":"blob","body":"# original msgpack-js author\nTim Caswell <tim@creationix.com>\n# v5 update\nChakrit Wichian <service@chakrit.net>\n"},"5c3f107284d6e09c23c475add738f86c351ad837":{"type":"blob","body":"# MSGPACK-JS-V5\n\n**Please see the [original README.md][1] from the source repository for more\ninformation.**\n\nThis is a port of [creationix/msgpack-js][0] to support the new MsgPack v5\nspecification.\n\n* New spec: https://github.com/msgpack/msgpack/blob/master/spec.md\n* Old spec: https://github.com/msgpack/msgpack/blob/master/spec-old.md\n\nPlease feel free to open issues/pull requests for support/discussion.\n\n# INSTALL\n\n```sh\n$ npm i msgpack-js-v5 --save\n```\n\n# EXTENSION\n\nSince there is no way to encode `undefined` inside the msgpack spec, an extension point i\nused for this purpose.\n\nSpecifically, the `fixext 1` type is used with all values being 0 to indicate undefined.\nOn the wire, it requires 3 bytes and should looks like this:\n\n```\n0xd4 | 0x00 | 0x00\n```\n\nWhere `|` is byte separator.\n\n# VERSIONING\n\nThis package will follows `msgpack-js` version for the time being. The version string will\nsimply be appended with `v5`.\n\nIf and when this package diverges from the original, we can start our own versioning. Or\nthis module could just be merged into the original `msgpack-js` module.\n\n [0]: https://github.com/creationix/msgpack-js\n [1]: https://github.com/creationix/msgpack-js/blob/master/README.markdown\n\n"},"751945205c169821dc77f30ed6b1c7db7b49b436":{"type":"blob","body":"\"use strict\";\n\nvar bops = require('bops');\n\nexports.encode = function (value) {\n  var toJSONed = []\n  var size = sizeof(value)\n  if(size == 0)\n    return undefined\n  var buffer = bops.create(size);\n  encode(value, buffer, 0);\n  return buffer;\n};\n\nexports.decode = decode;\n\n// http://wiki.msgpack.org/display/MSGPACK/Format+specification\n// I've extended the protocol to have two new types that were previously reserved.\n//   buffer 16  11011000  0xd8\n//   buffer 32  11011001  0xd9\n// These work just like raw16 and raw32 except they are node buffers instead of strings.\n//\n// Also I've added a type for `undefined`\n//   undefined  11000100  0xc4\n\nfunction Decoder(buffer, offset) {\n  this.offset = offset || 0;\n  this.buffer = buffer;\n}\nDecoder.prototype.map = function (length) {\n  var value = {};\n  for (var i = 0; i < length; i++) {\n    var key = this.parse();\n    value[key] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.buf = function (length) {\n  var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.raw = function (length) {\n  var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.array = function (length) {\n  var value = new Array(length);\n  for (var i = 0; i < length; i++) {\n    value[i] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.parse = function () {\n  var type = this.buffer[this.offset];\n  var value, length;\n  // FixRaw\n  if ((type & 0xe0) === 0xa0) {\n    length = type & 0x1f;\n    this.offset++;\n    return this.raw(length);\n  }\n  // FixMap\n  if ((type & 0xf0) === 0x80) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.map(length);\n  }\n  // FixArray\n  if ((type & 0xf0) === 0x90) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.array(length);\n  }\n  // Positive FixNum\n  if ((type & 0x80) === 0x00) {\n    this.offset++;\n    return type;\n  }\n  // Negative Fixnum\n  if ((type & 0xe0) === 0xe0) {\n    value = bops.readInt8(this.buffer, this.offset);\n    this.offset++;\n    return value;\n  }\n  switch (type) {\n  // raw 16\n  case 0xda:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.raw(length);\n  // raw 32\n  case 0xdb:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.raw(length);\n  // nil\n  case 0xc0:\n    this.offset++;\n    return null;\n  // false\n  case 0xc2:\n    this.offset++;\n    return false;\n  // true\n  case 0xc3:\n    this.offset++;\n    return true;\n  // undefined\n  case 0xc4:\n    this.offset++;\n    return undefined;\n  // uint8\n  case 0xcc:\n    value = this.buffer[this.offset + 1];\n    this.offset += 2;\n    return value;\n  // uint 16\n  case 0xcd:\n    value = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // uint 32\n  case 0xce:\n    value = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // uint64\n  case 0xcf:\n    value = bops.readUInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // int 8\n  case 0xd0:\n    value = bops.readInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return value;\n  // int 16\n  case 0xd1:\n    value = bops.readInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // int 32\n  case 0xd2:\n    value = bops.readInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // int 64\n  case 0xd3:\n    value = bops.readInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // map 16\n  case 0xde:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.map(length);\n  // map 32\n  case 0xdf:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.map(length);\n  // array 16\n  case 0xdc:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.array(length);\n  // array 32\n  case 0xdd:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.array(length);\n  // buffer 16\n  case 0xd8:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.buf(length);\n  // buffer 32\n  case 0xd9:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.buf(length);\n  // float\n  case 0xca:\n    value = bops.readFloatBE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // double\n  case 0xcb:\n    value = bops.readDoubleBE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  }\n  throw new Error(\"Unknown type 0x\" + type.toString(16));\n};\nfunction decode(buffer) {\n  var decoder = new Decoder(buffer);\n  var value = decoder.parse();\n  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + \" trailing bytes\");\n  return value;\n}\n\nfunction encodeableKeys (value) {\n  return Object.keys(value).filter(function (e) {\n    return 'function' !== typeof value[e] || !!value[e].toJSON\n  })\n}\n\nfunction encode(value, buffer, offset) {\n  var type = typeof value;\n  var length, size;\n\n  // Strings Bytes\n  if (type === \"string\") {\n    value = bops.from(value);\n    length = value.length;\n    // fix raw\n    if (length < 0x20) {\n      buffer[offset] = length | 0xa0;\n      bops.copy(value, buffer, offset + 1);\n      return 1 + length;\n    }\n    // raw 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xda;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // raw 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xdb;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    // buffer 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xd8;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // buffer 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xd9;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    if ((value << 0) !== value) {\n      buffer[offset] =  0xcb;\n      bops.writeDoubleBE(buffer, value, offset + 1);\n      return 9;\n    }\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) {\n        buffer[offset] = value;\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        buffer[offset] = 0xcc;\n        buffer[offset + 1] = value;\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        buffer[offset] = 0xcd;\n        bops.writeUInt16BE(buffer, value, offset + 1);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        buffer[offset] = 0xce;\n        bops.writeUInt32BE(buffer, value, offset + 1);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        buffer[offset] = 0xcf;\n        bops.writeUInt64BE(buffer, value, offset + 1);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) {\n      bops.writeInt8(buffer, value, offset);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      buffer[offset] = 0xd0;\n      bops.writeInt8(buffer, value, offset + 1);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      buffer[offset] = 0xd1;\n      bops.writeInt16BE(buffer, value, offset + 1);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      buffer[offset] = 0xd2;\n      bops.writeInt32BE(buffer, value, offset + 1);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      buffer[offset] = 0xd3;\n      bops.writeInt64BE(buffer, value, offset + 1);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  // undefined\n  if (type === \"undefined\") {\n    buffer[offset] = 0xc4;\n    return 1;\n  }\n\n  // null\n  if (value === null) {\n    buffer[offset] = 0xc0;\n    return 1;\n  }\n\n  // Boolean\n  if (type === \"boolean\") {\n    buffer[offset] = value ? 0xc3 : 0xc2;\n    return 1;\n  }\n\n  if('function' === typeof value.toJSON)\n    return encode(value.toJSON(), buffer, offset)\n\n  // Container Types\n  if (type === \"object\") {\n\n    size = 0;\n    var isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = value.length;\n    }\n    else {\n      var keys = encodeableKeys(value)\n      length = keys.length;\n    }\n\n    if (length < 0x10) {\n      buffer[offset] = length | (isArray ? 0x90 : 0x80);\n      size = 1;\n    }\n    else if (length < 0x10000) {\n      buffer[offset] = isArray ? 0xdc : 0xde;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      size = 3;\n    }\n    else if (length < 0x100000000) {\n      buffer[offset] = isArray ? 0xdd : 0xdf;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (var i = 0; i < length; i++) {\n        size += encode(value[i], buffer, offset + size);\n      }\n    }\n    else {\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += encode(key, buffer, offset + size);\n        size += encode(value[key], buffer, offset + size);\n      }\n    }\n\n    return size;\n  }\n  if(type === \"function\")\n    return undefined\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction sizeof(value) {\n  var type = typeof value;\n  var length, size;\n\n  // Raw Bytes\n  if (type === \"string\") {\n    // TODO: this creates a throw-away buffer which is probably expensive on browsers.\n    length = bops.from(value).length;\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    // double\n    if (value << 0 !== value) return 9;\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  // Boolean, null, undefined\n  if (type === \"boolean\" || type === \"undefined\" || value === null) return 1;\n\n  if('function' === typeof value.toJSON)\n    return sizeof(value.toJSON())\n\n  // Container Types\n  if (type === \"object\") {\n    if('function' === typeof value.toJSON)\n      value = value.toJSON()\n\n    size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (var i = 0; i < length; i++) {\n        size += sizeof(value[i]);\n      }\n    }\n    else {\n      var keys = encodeableKeys(value)\n      length = keys.length;\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += sizeof(key) + sizeof(value[key]);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  if(type === \"function\")\n    return 0\n  throw new Error(\"Unknown type \" + type);\n}\n\n\n"},"1ceb7e8e4c2404f05f2c17e1ac73f0916bda03e6":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure javascript\",\n  \"version\": \"0.3.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"dependencies\": {\n    \"bops\": \"~0.0.6\"\n  },\n  \"devDependencies\": {\n    \"tape\": \"~1.0.2\"\n  },\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"testling\": {\n    \"files\": \"test.js\",\n    \"browsers\": [\n      \"ie/9..latest\",\n      \"firefox/19..latest\",\n      \"chrome/25..latest\",\n      \"safari/latest\",\n      \"iphone/6\",\n      \"ipad/6\"\n    ]\n  }\n}\n"},"afac7827b2a67af53108cede75cb0312edbeec58":{"type":"blob","body":"\"use strict\";\nvar bops = require('bops');\nvar test = require('tape');\nvar msgpack = require('./msgpack');\nvar util = require('util');\n\nvar tests = [\n  true, false, null, undefined,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world', bops.from(\"Hello\"), bops.from(\"World\"),\n  [1,2,3], [], {name: \"Tim\", age: 29}, {},\n  {a: 1, b: 2, c: [1, 2, 3]}\n];\n\ntest('codec works as expected', function(assert) {\n\n  tests.forEach(function (input) {\n    var packed = msgpack.encode(input);\n    console.log(packed);\n    var output = msgpack.decode(packed);\n    if (bops.is(input)) {\n      assert.true(bops.is(output));\n      for (var i = 0, l = input.length; i < l; i++) {\n        assert.equal(input[i], output[i]);\n      }\n      assert.equal(input.length, output.length);\n    }\n    else {\n      assert.deepEqual(input, output);\n    }\n  });\n\n  assert.end();\n\n});\n\nfunction Foo () {\n  this.instance = true\n}\n\nFoo.prototype.blah = 324\n\nFoo.prototype.doThing = function () {}\n\nfunction jsonableFunction () {\n  console.log(\"can be json'ed\")\n}\n\njsonableFunction.toJSON = function () { return this.toString() }\n\nvar jsonLikes = [\n  {fun: function () {}, string: 'hello'},\n  {toJSON: function () {\n    return {object: true}\n  }},\n  new Date(0),\n  /regexp/,\n  new Foo(),\n  {fun: jsonableFunction},\n  jsonableFunction,\n]\n\ntest('treats functions same as json', function (assert) {\n  jsonLikes.forEach(function (input) {\n    assert.deepEqual(\n      msgpack.decode(msgpack.encode(input)),\n      JSON.parse(JSON.stringify(input)),\n      util.inspect(input)\n    )\n  })\n  assert.end()\n})\n\ntest('returns undefined for a function', function (assert) {\n  function noop () {}\n  assert.equal(msgpack.encode(noop), JSON.stringify(noop))\n  assert.end()\n})\n"},"931ccdfc11fb13eea3b97b0e464567157a25368b":{"type":"blob","body":"# msgpack for JavaScript\n\n[![node support](https://travis-ci.org/creationix/msgpack-js.png)](https://travis-ci.org/creationix/msgpack-js)\n\n[![browser support](https://ci.testling.com/creationix/msgpack-js.png)](https://ci.testling.com/creationix/msgpack-js)\n\n\nA handwritten msgpack encoder and decoder for Node.JS and modern browsers.\n\nThe original format can be found at <http://wiki.msgpack.org/display/MSGPACK/Format+specification>\n\n\n## Extension\n\nI've extended the format a little to allow for encoding and decoding of `undefined` and `Buffer` instances.\n\nThis required three new type codes that were previously marked as \"reserved\".\nThis change means that using these new types will render your serialized data\nincompatible with other messagepack implementations that don't have the same\nextension.\n\nThere are two new types for storing node `Buffer` instances. These work just \nlike \"raw 16\" and \"raw 32\" except they are node buffers instead of strings.\n\n    buffer 16  11011000  0xd8\n    buffer 32  11011001  0xd9\n\nAlso I've added a type for `undefined` that works just like the `null` type.\n\n    undefined  11000100  0xc4\n\n## Usage\n\n``` javascript\nvar msgpack = require('msgpack');\nvar assert = require('assert');\n\nvar initial = {Hello: \"World\"};\nvar encoded = msgpack.encode(initial);\nvar decoded = msgpack.decode(encoded);\n\nassert.deepEqual(initial, decoded);\n```\n\n"},"c2f802ed497ac913fdc7e1bf76e5ec66ea4bb19f":{"type":"blob","body":"\"use strict\";\nvar bops = require('bops');\nvar test = require('tape');\nvar msgpack = require('./msgpack');\nvar util = require('util');\n\nvar tests = [\n  true, false, null, undefined,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world', bops.from(\"Hello\"), bops.from(\"World\"),\n  [1,2,3], [], {name: \"Tim\", age: 29}, {},\n  {a: 1, b: 2, c: [1, 2, 3]},\n];\n\ntest('codec works as expected', function(assert) {\n\n  tests.forEach(function (input) {\n    var packed = msgpack.encode(input);\n    console.log(packed);\n    var output = msgpack.decode(packed);\n    if (bops.is(input)) {\n      assert.true(bops.is(output));\n      for (var i = 0, l = input.length; i < l; i++) {\n        assert.equal(input[i], output[i]);\n      }\n      assert.equal(input.length, output.length);\n    }\n    else {\n      assert.deepEqual(input, output);\n    }\n  });\n\n  assert.end();\n\n});\n"},"072d4e367b7fcdf381a13c3f8f81ad43e15402b8":{"type":"blob","body":"language: node_js\nnode_js:\n  - 0.10\n  - 0.8\n  - 0.6\nscript: node test.js\n"},"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d":{"type":"blob","body":"language: node_js\nnode_js:\n  - 0.8\n  - 0.6\nscript: node test.js\n"},"6c9ddafa9ad2b02682081328fe0aadf15002a778":{"type":"blob","body":"#!/usr/bin/env node\nvar msgpack = require('./msgpack');\nvar util = require('util');\nvar assert = require('assert');\n\nvar tests = [\n  true, false, null, undefined,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world', Buffer(\"Hello\"), Buffer(\"World\"),\n  [1,2,3], [], {name: \"Tim\", age: 29}, {},\n  {a: 1, b: 2, c: [1, 2, 3]},\n];\nfor (var i = 0, l = tests.length; i < l; i++) {\n  var test = tests[i];\n  if (typeof test === 'number') {\n    tests.push(test + 1);\n    tests.push(test - 1);\n    tests.push(test + 0.5);\n  }\n}\n[0x100, 0x1000, 0x10000, 0x100000].forEach(function (length) {\n  var list = new Array(length), obj = {};\n  for (var i = 0; i < length; i++) {\n    list[i] = i;\n    obj[i] = i;\n  }\n  tests.push(list);\n  tests.push(obj);\n});\n\nvar width = 80;\nif (process.stdout.isTTY) {\n  width = process.stdout.getWindowSize()[0];\n}\nvar mistakes = 0;\nfunction dump(value) {\n  if (typeof value === 'undefined' || Buffer.isBuffer(value)) {\n    return util.inspect(value).replace(/\\n */g, '');\n  }\n  return JSON.stringify(value);\n}\ntests.forEach(function (test) {\n  console.log(dump(test).substr(0, width));\n  var encoded = msgpack.encode(test);\n  console.log(encoded.inspect().substr(0, width));\n  var decoded = msgpack.decode(encoded);\n  try {\n    assert.deepEqual(test, decoded);\n    if (typeof test === \"object\" && test !== null) {\n      assert.equal(test.constructor, decoded.constructor);\n    }\n  } catch (err) {\n    console.error();\n    console.error(dump(test).substr(0, width));\n    console.error(encoded.inspect().substr(0, width));\n    console.error(dump(decoded).substr(0, width));\n    console.error(err.stack);\n    mistakes++;\n  }\n});\nif (mistakes) {\n  console.error(mistakes + \" tests failed!\");\n} else {\n  console.log(\"\\nAll tests passed successfully!\");\n}\nprocess.exit(mistakes.length);\n"},"48fe0cd67caa7dbfbefccd6a8718d1c5eefe41a7":{"type":"blob","body":"language: node_js\nscript: node test.js\n"},"84dee00b735c8ff6a54e75782bfeef42fb920cd0":{"type":"blob","body":"/*global Buffer*/\n\nfunction Packer(push) {\n  this.push = push;\n}\nPacker.prototype = {\n  constructor: Packer,\n  INT8: function (num) {\n    this.push((num >>> 0) & 0xff);\n  },\n  INT16: function (num) {\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT32: function (num) {\n    this.push((num >>> 24) & 0xff);\n    this.push((num >>> 16) & 0xff);\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT64: function (num) {\n    // TODO: Implement this, it's tricky\n    // Needs to accept unsigned up to 64 bits\n    // and signed up to 63 bits + sign bit\n    throw new Error(\"INT64 not implemented!\");\n  },\n  SINGLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 single precision floating point number \n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    throw new Error(\"SINGLE not implemented!\");\n  },\n  DOUBLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 double precision floating point number\n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    throw new Error(\"DOUBLE not implemented!\");\n  },\n  integer: function (num) {\n    if (num >= 0) {\n      // positive fixnum\n      if (num < 0x80) {\n        this.INT8(num);\n        return;\n      }\n      // uint 8\n      if (num < 0x100) {\n        this.push(0xcc);\n        this.INT8(num);\n        return;\n      }\n      // uint 16\n      if (num < 0x10000) {\n        this.push(0xcd);\n        this.INT16(num);\n        return;\n      }\n      // uint 32\n      if (num < 0x100000000) {\n        this.push(0xce);\n        this.INT32(num);\n        return;\n      }\n      // uint 64\n      if (num < 0x10000000000000000) {\n        this.push(0xcf);\n        this.INT64(num);\n        return;\n      }\n      throw new Error(\"Number to large\");\n    }\n    // negative fixnum\n    if (num >= -0x20) {\n      this.INT8(num);\n      return;\n    } \n    // int 8\n    if (num >= -0x80) {\n      this.push(0xd0);\n      this.INT8(num);\n      return;\n    }\n    // int 16\n    if (num >= -0x8000) {\n      this.push(0xd1);\n      this.INT16(num);\n      return;\n    }\n    // int 32\n    if (num >= -0x80000000) {\n      this.push(0xd2);\n      this.INT32(num);\n      return;\n    }\n    // int 64\n    if (num >= -0x8000000000000000) {\n      this.push(0xd3);\n      this.INT64(num);\n      return;\n    }\n    throw new Error(\"Number to small\");\n  },\n  float: function (num) {\n    // TODO: Detect when SINGLE is enough precision somehow\n    this.push(0xcb);\n    this.DOUBLE(num);\n  },\n  raw: function (buffer) {\n    // fix raw\n    if (buffer.length < 0x20) {\n      this.push(0xa0 | buffer.length);\n      this.push(buffer);\n      return;\n    }\n    // raw 16\n    if (buffer.length < 0x10000) {\n      this.push(0xda);\n      this.push(buffer);\n      return;\n    }\n    // raw 32\n    if (buffer.length < 0x100000000) {\n      this.push(0xdb);\n      this.push(buffer);\n      return;\n    }\n    throw new Error(\"Raw buffer too long\");\n  },\n  array: function (val) {\n    if (val.length < 0x10) {\n      // fix array\n      this.push(0x90 | val.length);\n    } else if (val.length < 0x10000) {\n      // array 16\n      this.push(0xdc);\n      this.INT16(val.length);\n    } else if (val.length < 0x100000000) {\n      // array 32\n      this.push(0xdd);\n      this.INT32(val.length);\n    } else {\n      throw new Error(\"Array too long\");\n    }\n    val.forEach(function (item) {\n      this.pack(item);\n    }, this);\n  },\n  map: function (val) {\n    var keys = Object.keys(val);\n    if (keys.length < 0x10) {\n      // fix map\n      this.push(0x80 | keys.length);\n    } else if (keys.length < 0x10000) {\n      // map 16\n      this.push(0xde);\n      this.INT16(keys.length);\n    } else if (keys.length < 0x100000000) {\n      // map 32\n      this.push(0xdf);\n      this.INT32(keys.length);\n    } else {\n      throw new Error(\"Map too long\");\n    }\n    keys.forEach(function (key) {\n      this.pack(key);\n      this.pack(val[key]);\n    }, this);\n  },\n  pack: function (val) {\n    // nil\n    if (val === null || val === undefined) {\n      this.push(0xc0);\n      return;\n    }\n    // true\n    if (val === true) {\n      this.push(0xc3);\n      return;\n    }\n    // false\n    if (val === false) {\n      this.push(0xc2);\n      return;\n    }\n    if (typeof val === 'number') {\n      if (Math.floor(val) === val) {\n        this.integer(val);\n        return;\n      }\n      this.float(val);\n      return;\n    }\n    if (typeof val === 'string') {\n      // Encode strings as buffers\n      this.raw(new Buffer(val));\n      return;\n    }\n    if (typeof val === 'object') {\n      if (val instanceof Buffer) {\n        this.raw(val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        this.array(val);\n        return;\n      }\n      this.map(val);\n      return;\n    }\n    console.dir(val);\n    throw new Error(\"Unknown value\");\n  }\n};\n\nfunction Parser(emit) {\n  this.emit = emit;\n  this.left = 0;\n  this.buffer = [];\n  this.consume = null;\n}\nParser.prototype = {\n  constructor: Parser,\n  push: function (byte) {\n    // Accept buffers as batch bytes\n    if (byte instanceof Buffer) {\n      for (var i = 0, l = byte.length; i < l; i++) {\n        this.push(byte[i]);\n      }\n      return;\n    }\n    // Hook to consume message bodies\n    if (this.consume) {\n      if (this.left > 0) {\n        this.buffer.push(byte);\n        this.left--;\n      }\n      if (this.left === 0) {\n        this[this.consume]();\n        this.buffer.length = 0;\n        this.consume = null;\n      }\n      return;\n    }\n    if (byte < 0x80) {\n      // fixnum\n      this.emit(byte);\n      return;\n    }\n    if (byte >= 0xe0) {\n      // negative fixnum\n      this.emit(byte - 0x100);\n      return;\n    }\n    if (byte >= 0xc0) {\n      switch (byte) {\n        case 0xc0: this.emit(null); return;\n        case 0xc2: this.emit(false); return;\n        case 0xc3: this.emit(true); return;\n        case 0xca: this.consume = 'float'; this.left = 4; return;\n        case 0xca: this.consume = 'double'; this.left = 8; return;\n        case 0xcc: this.consume = 'uint8'; this.left = 1; return;\n        case 0xcd: this.consume = 'uint16'; this.left = 2; return;\n        case 0xce: this.consume = 'uint32'; this.left = 4; return;\n        case 0xcf: this.consume = 'uint64'; this.left = 8; return;\n        case 0xd0: this.consume = 'int8'; this.left = 1; return;\n        case 0xd1: this.consume = 'int16'; this.left = 2; return;\n        case 0xd2: this.consume = 'int32'; this.left = 4; return;\n        case 0xd3: this.consume = 'int64'; this.left = 8; return;\n        case 0xda: this.consume = 'raw16'; this.left = 2; return;\n        case 0xdb: this.consume = 'raw32'; this.left = 4; return;\n        case 0xdc: this.consume = 'array16'; this.left = 2; return;\n        case 0xdd: this.consume = 'array32'; this.left = 4; return;\n        case 0xde: this.consume = 'map16'; this.left = 2; return;\n        case 0xdf: this.consume = 'map32'; this.left = 4; return;\n      }\n      throw new Error(\"Invalid variable code\");\n    }\n    if (byte >= 0xa0) {\n      // FixRaw\n      this.consume = 'raw';\n      this.left = byte & 0x1f;\n      return;\n    }\n    if (byte >= 0x90) {\n      // FixArray\n      this.array(byte & 0xf);\n      return;\n    }\n    if (byte >= 0x80) {\n      // FixMap\n      this.map(byte & 0xf);\n      return;\n    }\n    throw new Error(\"Unknown sequence encountered\");\n  },\n  uint8: function () {\n    this.emit(this.buffer[0]);\n  },\n  uint16: function () {\n    this.emit((this.buffer[0] << 8) |\n              (this.buffer[1]));\n  },\n  uint32: function () {\n    this.emit((this.buffer[0] << 24) |\n              (this.buffer[1] << 16) |\n              (this.buffer[2] << 8) |\n              (this.buffer[3]));\n  },\n  int8: function () {\n    this.emit(this.buffer[0] - 0x100);\n  },\n  int16: function () {\n    this.emit((this.buffer[0] << 8) |\n              (this.buffer[1]) - 0x10000);\n  },\n  int32: function () {\n    // TODO: Find out if this overflow trick always works.\n    this.emit((this.buffer[0] << 24) |\n              (this.buffer[1] << 16) |\n              (this.buffer[2] << 8) |\n              (this.buffer[3]));\n  },\n  array16: function () {\n    this.array((this.buffer[0] << 8) |\n               (this.buffer[1]));\n  },\n  array32: function () {\n    this.array((this.buffer[0] << 24) |\n               (this.buffer[1] << 16) |\n               (this.buffer[2] << 8) |\n               (this.buffer[3]));\n  },\n  map16: function () {\n    this.map((this.buffer[0] << 8) |\n             (this.buffer[1]));\n  },\n  map32: function () {\n    this.map((this.buffer[0] << 24) |\n             (this.buffer[1] << 16) |\n             (this.buffer[2] << 8) |\n             (this.buffer[3]));\n  },\n  raw: function () {\n    var data = new Buffer(this.buffer);\n    if (this.encoding) {\n      this.emit(data.toString(this.encoding));\n    } else {\n      this.emit(data);\n    }\n  },\n  array: function (items) {\n    var results = [];\n    if (items === 0) {\n      this.emit(results);\n      return;\n    }\n    var oldEmit = this.emit;\n    this.emit = function (result) {\n      results.push(result);\n      items--;\n      if (items === 0) {\n        this.emit = oldEmit;\n        this.emit(results);\n      }\n    };\n  },\n  map: function (items) {\n    var results = {};\n    if (items === 0) {\n      this.emit(results);\n      return;\n    }\n    var oldEmit = this.emit;\n    var key;\n    this.emit = function (result) {\n      if (key === undefined) {\n        key = result.toString();\n        return;\n      }\n      results[key] = result;\n      key = undefined;\n      items--;\n      if (items === 0) {\n        this.emit = oldEmit;\n        this.emit(results);\n      }\n    };\n  }\n};\n\nmodule.exports = {\n  Packer: Packer,\n  Parser: Parser,\n  pack: function (value) {\n    var bytes = [];\n    function accum(byte) {\n      bytes.push(byte);\n    }\n    var packer = new Packer(accum);\n    packer.pack(value);\n    var length = 0;\n    bytes.forEach(function (byte) {\n      if (typeof byte === 'number') {\n        length++;\n      } else {  \n        length += byte.length;\n      }\n    });\n    var buffer = new Buffer(length);\n    for(var i = 0; i < length; i++) {\n      buffer[i] = 0;\n    }\n    var offset = 0;\n    bytes.forEach(function (byte) {\n      if (typeof byte === 'number') {\n        buffer[offset] = byte;\n        offset++;\n      } else {\n        byte.copy(buffer, offset);\n        offset += byte.length;\n      }\n    });\n    return buffer;\n  },\n  unpack: function (buffer, encoding) {\n    var value;\n    var parser = new Parser(function (result) {\n      value = result;\n    });\n    parser.encoding = encoding;\n    parser.push(buffer);\n    return value;\n  }\n};\n"},"dc8861d41b011f15b91c5c78411eb5a49496fd7a":{"type":"blob","body":"# msgpack for node\n\nThis is my own experiment with a hand written encoder and parser for msgpack for node.\n\nThe initial implementation is mostly done, missing is 64bit numbers and float/double numbers.\n\nNext is heavy testing and performance tuning...\n"},"9db607e208c033e0829488d0244ef114712b1d02":{"type":"blob","body":"/*global Buffer*/\nvar assert = require('assert');\nvar msgpack = require('./msgpack');\n\nvar o = {\"a\" : 1, \"b\" : 2, \"c\" : [1, 2, 3]};\nconsole.dir(o);\nvar b = msgpack.pack(o);\nconsole.dir(new Buffer(JSON.stringify(b)));\nconsole.dir(b);\nvar oo = msgpack.unpack(b, 'utf8');\n\nassert.deepEqual(oo, o);\n\n"},"9bd677f09102818ab70b198ac3de537a9821d892":{"type":"blob","body":"# msgpack for node\n\nThis is my own experiment with a hand written encoder and parser for msgpack for node.\n\nThis is incomplete at the moment.  The encoder is mostly there, but the decoder is barely started.\n"},"62d1d508d302136ef86791df0c6350bb1420ac32":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"9bd677f09102818ab70b198ac3de537a9821d892"},{"mode":33188,"name":"msgpack.js","hash":"84dee00b735c8ff6a54e75782bfeef42fb920cd0"},{"mode":33188,"name":"test.js","hash":"ed8ce267449a2e4a290db802af8d6ab6ea0ec545"},{"mode":33188,"name":"test2.js","hash":"9db607e208c033e0829488d0244ef114712b1d02"}]},"04e54d494b8d298440279438065e25bcce24059e":{"type":"blob","body":"/*global Buffer*/\n\nfunction Packer(push) {\n  this.push = push;\n}\nPacker.prototype = {\n  constructor: Packer,\n  INT8: function (num) {\n    this.push((num >>> 0) & 0xff);\n  },\n  INT16: function (num) {\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT32: function (num) {\n    this.push((num >>> 24) & 0xff);\n    this.push((num >>> 16) & 0xff);\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT64: function (num) {\n    // TODO: Implement this, it's tricky\n    // Needs to accept unsigned up to 64 bits\n    // and signed up to 63 bits + sign bit\n    throw new Error(\"INT64 not implemented!\");\n  },\n  SINGLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 single precision floating point number \n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    throw new Error(\"SINGLE not implemented!\");\n  },\n  DOUBLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 double precision floating point number\n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    throw new Error(\"DOUBLE not implemented!\");\n  },\n  integer: function (num) {\n    if (num >= 0) {\n      // positive fixnum\n      if (num < 0x80) {\n        this.INT8(num);\n        return;\n      }\n      // uint 8\n      if (num < 0x100) {\n        this.push(0xcc);\n        this.INT8(num);\n        return;\n      }\n      // uint 16\n      if (num < 0x10000) {\n        this.push(0xcd);\n        this.INT16(num);\n        return;\n      }\n      // uint 32\n      if (num < 0x100000000) {\n        this.push(0xce);\n        this.INT32(num);\n        return;\n      }\n      // uint 64\n      if (num < 0x10000000000000000) {\n        this.push(0xcf);\n        this.INT64(num);\n        return;\n      }\n      throw new Error(\"Number to large\");\n    }\n    // negative fixnum\n    if (num >= -0x20) {\n      this.INT8(num);\n      return;\n    } \n    // int 8\n    if (num >= -0x80) {\n      this.push(0xd0);\n      this.INT8(num);\n      return;\n    }\n    // int 16\n    if (num >= -0x8000) {\n      this.push(0xd1);\n      this.INT16(num);\n      return;\n    }\n    // int 32\n    if (num >= -0x80000000) {\n      this.push(0xd2);\n      this.INT32(num);\n      return;\n    }\n    // int 64\n    if (num >= -0x8000000000000000) {\n      this.push(0xd3);\n      this.INT64(num);\n      return;\n    }\n    throw new Error(\"Number to small\");\n  },\n  float: function (num) {\n    // TODO: Detect when SINGLE is enough precision somehow\n    this.push(0xcb);\n    this.DOUBLE(num);\n  },\n  raw: function (buffer) {\n    // fix raw\n    if (buffer.length < 0x20) {\n      this.push(0xa0 || buffer.length);\n      this.push(buffer);\n      return;\n    }\n    // raw 16\n    if (buffer.length < 0x10000) {\n      this.push(0xda);\n      this.push(buffer);\n      return;\n    }\n    // raw 32\n    if (buffer.length < 0x100000000) {\n      this.push(0xdb);\n      this.push(buffer);\n      return;\n    }\n    throw new Error(\"Raw buffer too long\");\n  },\n  array: function (val) {\n    if (val.length < 0x10) {\n      // fix array\n      this.push(0x90 | val.length);\n    } else if (val.length < 0x10000) {\n      // array 16\n      this.push(0xdc);\n      this.INT16(val.length);\n    } else if (val.length < 0x100000000) {\n      // array 32\n      this.push(0xdd);\n      this.INT32(val.length);\n    } else {\n      throw new Error(\"Array too long\");\n    }\n    val.forEach(function (item) {\n      this.pack(item);\n    }, this);\n  },\n  map: function (val) {\n    var keys = Object.keys(val);\n    if (keys.length < 0x10) {\n      // fix map\n      this.push(0x80 | keys.length);\n    } else if (keys.length < 0x10000) {\n      // map 16\n      this.push(0xde);\n      this.INT16(keys.length);\n    } else if (keys.length < 0x100000000) {\n      // map 32\n      this.push(0xdf);\n      this.INT32(keys.length);\n    } else {\n      throw new Error(\"Map too long\");\n    }\n    keys.forEach(function (key) {\n      this.pack(key);\n      this.pack(val[key]);\n    }, this);\n  },\n  pack: function (val) {\n    // nil\n    if (val === null || val === undefined) {\n      this.push(0xc0);\n      return;\n    }\n    // true\n    if (val === true) {\n      this.push(0xc3);\n      return;\n    }\n    // false\n    if (val === false) {\n      this.push(0xc2);\n      return;\n    }\n    if (typeof val === 'number') {\n      if (Math.floor(val) === val) {\n        this.integer(val);\n        return;\n      }\n      this.float(val);\n      return;\n    }\n    if (typeof val === 'string') {\n      // Encode strings as buffers\n      this.raw(new Buffer(val));\n      return;\n    }\n    if (typeof val === 'object') {\n      if (val instanceof Buffer) {\n        this.raw(val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        this.array(val);\n        return;\n      }\n      this.map(val);\n      return;\n    }\n    console.dir(val);\n    throw new Error(\"Unknown value\");\n  }\n};\n\nfunction Parser(emit) {\n  this.emit = emit;\n  this.left = 0;\n  this.buffer = [];\n  this.consume = null;\n}\nParser.prototype = {\n  constructor: Parser,\n  push: function (byte) {\n    // Accept buffers as batch bytes\n    if (byte instanceof Buffer) {\n      for (var i = 0, l = byte.length; i < l; i++) {\n        this.push(byte[i]);\n      }\n      return;\n    }\n    // Hook to consume message bodies\n    if (this.left > 0) {\n      this.buffer.push(byte);\n      this.left--;\n      if (this.left === 0) {\n        this[this.consume]();\n        this.buffer.length = 0;\n        this.consume = null;\n      }\n      return;\n    }\n    if (byte < 0x80) {\n      // fixnum\n      this.emit(byte);\n      return;\n    }\n    if (byte >= 0xe0) {\n      // negative fixnum\n      this.emit(byte - 0x100);\n      return;\n    }\n    if (byte >= 0xc0) {\n      switch (byte) {\n        case 0xc0: this.emit(null); return;\n        case 0xc2: this.emit(false); return;\n        case 0xc3: this.emit(true); return;\n        case 0xca: this.consume = 'float'; this.left = 4; return;\n        case 0xca: this.consume = 'double'; this.left = 8; return;\n        case 0xcc: this.consume = 'uint8'; this.left = 1; return;\n        case 0xcd: this.consume = 'uint16'; this.left = 2; return;\n        case 0xce: this.consume = 'uint32'; this.left = 4; return;\n        case 0xcf: this.consume = 'uint64'; this.left = 8; return;\n        case 0xd0: this.consume = 'int8'; this.left = 1; return;\n        case 0xd1: this.consume = 'int16'; this.left = 2; return;\n        case 0xd2: this.consume = 'int32'; this.left = 4; return;\n        case 0xd3: this.consume = 'int64'; this.left = 8; return;\n        case 0xda: this.consume = 'raw16'; this.left = 2; return;\n        case 0xdb: this.consume = 'raw32'; this.left = 4; return;\n        case 0xdc: this.consume = 'array16'; this.left = 2; return;\n        case 0xdd: this.consume = 'array32'; this.left = 4; return;\n        case 0xde: this.consume = 'map16'; this.left = 2; return;\n        case 0xdf: this.consume = 'map32'; this.left = 4; return;\n      }\n      throw new Error(\"Invalid variable code\");\n    }\n    if (byte >= 0xa0) {\n      // FixRaw\n      throw new Error(\"Not Implemented\");\n      return;\n    }\n    if (byte >= 0x90) {\n      // FixArray\n      throw new Error(\"Not Implemented\");\n      return;\n    }\n    if (byte >= 0x80) {\n      // FixMap\n      throw new Error(\"Not Implemented\");\n      return;\n    }\n    throw new Error(\"Unknown sequence encountered\");\n  },\n  uint8: function () {\n    this.emit(this.buffer[0]);\n  },\n  uint16: function () {\n    this.emit((this.buffer[0] << 8) +\n              (this.buffer[1]));\n  },\n  uint32: function () {\n    this.emit((this.buffer[0] << 24) +\n              (this.buffer[1] << 16) +\n              (this.buffer[2] << 8) +\n              (this.buffer[3]));\n  },\n  int8: function () {\n    this.emit(this.buffer[0] - 0x100);\n  },\n  int16: function () {\n    this.emit((this.buffer[0] << 8) +\n              (this.buffer[1]) - 0x10000);\n  },\n  int32: function () {\n    console.log(\"\\nint32\");\n    this.emit((this.buffer[0] << 24) +\n              (this.buffer[1] << 16) +\n              (this.buffer[2] << 8) +\n              (this.buffer[3]));\n  },\n\n\n};\n\nfunction encode(val) {\n  var bytes = [];\n  function accum(byte) {\n    bytes.push(byte);\n  }\n  var packer = new Packer(accum);\n  console.dir(packer);\n  console.dir(packer.__proto__);\n  packer.pack(val);\n  return bytes;\n}\n\nmodule.exports = {\n  Packer: Packer,\n  Parser: Parser,\n  pack: function (value) {\n    var bytes = [];\n    function accum(byte) {\n      bytes.push(byte);\n    }\n    var packer = new Packer(accum);\n    packer.pack(value);\n    // TODO: roll in buffers somehow\n    return new Buffer(bytes);\n  },\n  unpack: function (buffer) {\n    var value;\n    var parser = new Parser(function (result) {\n      value = result;\n    });\n    parser.push(buffer);\n    return value;\n  }\n};\n"},"97c67a6b28101e9a7660cc70f234bd4111176ba7":{"type":"blob","body":"var Stream = require('stream').Stream;\n\nfunction Encoder(onData) {\n  Stream.call(this);\n  this.buffer = new Buffer(1024);\n  this.offset = 0;\n  if (onData) {\n    this.on('data', onData);\n  }\n}\nEncoder.prototype = {\n  __proto__: Stream.prototype,\n  constructor: Encoder,\n  \n  push: function (byte) {\n    this.buffer[this.offset++] = byte;\n    if (this.offset === 1024) {\n      this.flush();\n    }\n  },\n  chunk: function (chunk) {\n    var length;\n    // Handle string chunks\n    if (typeof chunk === 'string') {\n      length = Buffer.byteLength(chunk);\n      if (length <= 1024) {\n        if (length > 1024 - this.offset) {\n          this.flush();\n        }\n        this.buffer.write(chunk, this.offset);\n        this.offset += length;\n        if (this.offset === 1024) {\n          this.flush();\n        }\n        return;\n      }\n      this.chunk(new Buffer(chunk));\n      return;\n    }\n    length = chunk.length;\n    if (length <= 1024) {\n      if (chunk.length > 1024 - this.offset) {\n        this.flush();\n      }\n      chunk.copy(this.buffer, this.offset);\n      this.offset += chunk.length;\n      if (this.offset === 1024) {\n        this.flush();\n      }\n      return;      \n    }\n\n    // Data is too big to fit, flush what we got already\n    this.flush();\n    this.emit('data', chunk);\n  },\n\n  flush: function () {\n    if (this.offset) {\n      this.emit('data', this.buffer.slice(0, this.offset));\n      var b = this.buffer.slice(0, this.offset);\n      this.buffer = new Buffer(1024);\n      this.offset = 0;\n    }\n  },\n  \n  end: function () {\n    this.flush();\n    this.emit('end');\n  },\n  \n  INT8: function (num) {\n    this.push((num >>> 0) & 0xff);\n  },\n  INT16: function (num) {\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT32: function (num) {\n    this.push((num >>> 24) & 0xff);\n    this.push((num >>> 16) & 0xff);\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT64: function (num) {\n    if (num < 0) {\n      // TODO: Make sure this works for negative numbers too\n      this.emit('error', new Error(\"INT64 not implemented for negative numbers!\"));\n      return;\n    }\n    var high = Math.floor(num / 0x100000000);\n    var low = num - high * 0x100000000;\n    this.INT32(high);\n    this.INT32(low);\n  },\n  SINGLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 single precision floating point number \n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    this.emit('error', new Error(\"SINGLE not implemented!\"));\n  },\n  DOUBLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 double precision floating point number\n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    this.emit('error', new Error(\"DOUBLE not implemented!\"));\n  },\n  integer: function (num) {\n    if (num >= 0) {\n      // positive fixnum\n      if (num < 0x80) {\n        this.INT8(num);\n        return;\n      }\n      // uint 8\n      if (num < 0x100) {\n        this.push(0xcc);\n        this.INT8(num);\n        return;\n      }\n      // uint 16\n      if (num < 0x10000) {\n        this.push(0xcd);\n        this.INT16(num);\n        return;\n      }\n      // uint 32\n      if (num < 0x100000000) {\n        this.push(0xce);\n        this.INT32(num);\n        return;\n      }\n      // uint 64\n      if (num < 0x10000000000000000) {\n        this.push(0xcf);\n        this.INT64(num);\n        return;\n      }\n      this.emit('error', new Error(\"Number to large\"));\n    }\n    // negative fixnum\n    if (num >= -0x20) {\n      this.INT8(num);\n      return;\n    } \n    // int 8\n    if (num >= -0x80) {\n      this.push(0xd0);\n      this.INT8(num);\n      return;\n    }\n    // int 16\n    if (num >= -0x8000) {\n      this.push(0xd1);\n      this.INT16(num);\n      return;\n    }\n    // int 32\n    if (num >= -0x80000000) {\n      this.push(0xd2);\n      this.INT32(num);\n      return;\n    }\n    // int 64\n    if (num >= -0x8000000000000000) {\n      this.push(0xd3);\n      this.INT64(num);\n      return;\n    }\n    this.emit('error', new Error(\"Number to small\"));\n  },\n  float: function (num) {\n    // TODO: Detect when SINGLE is enough precision somehow\n    this.push(0xcb);\n    this.DOUBLE(num);\n  },\n  raw: function (buffer) {\n    var length = buffer.length;\n    // fix raw\n    if (length < 0x20) {\n      this.push(0xa0 | length);\n      this.chunk(buffer);\n      return;\n    }\n    // raw 16\n    if (length < 0x10000) {\n      this.push(0xda);\n      this.INT16(length);\n      this.chunk(buffer);\n      return;\n    }\n    // raw 32\n    if (length < 0x100000000) {\n      this.push(0xdb);\n      this.INT32(length);\n      this.chunk(buffer);\n      return;\n    }\n    this.emit('error', new Error(\"Raw buffer too long\"));\n  },\n  array: function (val) {\n    var length = val.length;\n    if (length < 0x10) {\n      // fix array\n      this.push(0x90 | length);\n    } else if (length < 0x10000) {\n      // array 16\n      this.push(0xdc);\n      this.INT16(length);\n    } else if (length < 0x100000000) {\n      // array 32\n      this.push(0xdd);\n      this.INT32(length);\n    } else {\n      this.emit('error', new Error(\"Array too long\"));\n    }\n    for (var i = 0; i < length; i++) {\n      this.pack(val[i]);\n    }\n  },\n  map: function (val) {\n    var keys = Object.keys(val);\n    var length = keys.length;\n    if (length < 0x10) {\n      // fix map\n      this.push(0x80 | length);\n    } else if (length < 0x10000) {\n      // map 16\n      this.push(0xde);\n      this.INT16(length);\n    } else if (length < 0x100000000) {\n      // map 32\n      this.push(0xdf);\n      this.INT32(length);\n    } else {\n      this.emit('error', new Error(\"Map too long\"));\n    }\n    for (var i = 0; i < length; i++) {\n      var key = keys[i];\n      this.raw(key);\n      this.pack(val[key]);\n    }\n  },\n  pack: function (val) {\n    // typeof is fastest way to check if it's a number.\n    // http://jsperf.com/number-detection\n    if (typeof val === 'number') {\n      // Math.floor to test if it's an int\n      // http://jsperf.com/integer-check\n      if (Math.floor(val) === val) {\n        this.integer(val);\n        return;\n      }\n      this.float(val);\n      return;\n    }\n    // nil\n    if (val === null) {\n      this.push(0xc0);\n      return;\n    }\n    // true\n    if (val === true) {\n      this.push(0xc3);\n      return;\n    }\n    // false\n    if (val === false) {\n      this.push(0xc2);\n      return;\n    }\n    if (typeof val === 'string') {\n      // Encode strings as buffers\n      this.raw(val);\n      return;\n    }\n    if (typeof val === 'object') {\n      if (val instanceof Buffer) {\n        this.raw(val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        this.array(val);\n        return;\n      }\n      this.map(val);\n      return;\n    }\n    this.emit('error', new Error(\"Unknown value: \" + val));\n  }\n};\n\nvar fs = require('fs');\nvar out = fs.createWriteStream('my.db');\nvar json = fs.readFileSync('sample.json', 'utf8');\nvar mine = new Encoder();\nmine.pipe(process.stdout);\n//mine.pack(1);\n//mine.pack(0);\n//mine.pack(true);\n//mine.pack([1,2,3]);\n//mine.pack({Hello: \"World\"});\njson.split(\"\\n\").forEach(function (line) {\n  try {\n    mine.pack(JSON.parse(line));\n  } catch (err) {\n  }\n});\nmine.end();\n\n"},"401bc02f77903c930c4b33e1d6f14d4ab9d49b2d":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"33118490d518b8b3edbf926d1e35e4e5a3dd805e"},{"mode":33188,"name":"msgpack.js","hash":"9108faf6b226321507525a699856b5d5ae427284"},{"mode":33188,"name":"test.js","hash":"8c49dcc4d3f942cf9e9ed48b70520b836bcc9075"}]},"9677ebacd5d1450706dd109dc891093903f058a1":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"6d4ee24c360c599a71ab14e9f12c458ccce1e646"},{"mode":33188,"name":"msgpack.js","hash":"9108faf6b226321507525a699856b5d5ae427284"},{"mode":33188,"name":"package.json","hash":"ea0ab5cd2e170e0fc131f90ff08045b3c4183b1a"},{"mode":33188,"name":"test.js","hash":"8c49dcc4d3f942cf9e9ed48b70520b836bcc9075"}]},"7d58960fc86b932a7ba3f50b40f7b8eb02cc11c9":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"6d4ee24c360c599a71ab14e9f12c458ccce1e646"},{"mode":33188,"name":"msgpack.js","hash":"9108faf6b226321507525a699856b5d5ae427284"},{"mode":33188,"name":"package.json","hash":"ea0ab5cd2e170e0fc131f90ff08045b3c4183b1a"},{"mode":33188,"name":"test.js","hash":"eb579ea870af3232f018b87d601dad9d1dbf70bf"}]},"4fa3bdeaa2518e266d3b9d83e20134a0bf097735":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"bae85dcb004c3b1023e0d5da461ddfd861246567"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"6c773b78f234659fdbe336336d242401b91aad6f"},{"mode":33188,"name":"test.js","hash":"eb579ea870af3232f018b87d601dad9d1dbf70bf"}]},"3a142438464a5ca71228a4a6ee9455e610e7a76c":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"bae85dcb004c3b1023e0d5da461ddfd861246567"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"85de88d3b7ea78dc2e81f7a182d947ab5cb83ca6"},{"mode":33188,"name":"test.js","hash":"eb579ea870af3232f018b87d601dad9d1dbf70bf"}]},"65e63323cf2f03e952cd3123ae60f00ac6520a7b":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"48fe0cd67caa7dbfbefccd6a8718d1c5eefe41a7"},{"mode":33188,"name":"README.markdown","hash":"e8757048063dc4c3d6af4401220ac23581f2c60c"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"85de88d3b7ea78dc2e81f7a182d947ab5cb83ca6"},{"mode":33261,"name":"test.js","hash":"771cbb73f2c9242618472c8049402951674e839a"}]},"8fccfc79aca3ef169a08e19e8280399d838c47db":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"e8757048063dc4c3d6af4401220ac23581f2c60c"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"85de88d3b7ea78dc2e81f7a182d947ab5cb83ca6"},{"mode":33261,"name":"test.js","hash":"771cbb73f2c9242618472c8049402951674e839a"}]},"f61ad382d7ab165be2244e8087beb2dee97acc23":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"e8757048063dc4c3d6af4401220ac23581f2c60c"},{"mode":33188,"name":"msgpack.js","hash":"7db951071bf320f25006a93ca5a6e76c9ee91c72"},{"mode":33188,"name":"package.json","hash":"85de88d3b7ea78dc2e81f7a182d947ab5cb83ca6"},{"mode":33261,"name":"test.js","hash":"6c9ddafa9ad2b02682081328fe0aadf15002a778"}]},"44dc81302d7f4cc7173ba681aad2b110e8851f80":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"e8757048063dc4c3d6af4401220ac23581f2c60c"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"7b83f33631db2ef0ca9603d678cbda23c4144cb9"},{"mode":33261,"name":"test.js","hash":"6c9ddafa9ad2b02682081328fe0aadf15002a778"}]},"be68618a463ad94ec7dff7a1b8c9839b920e00d7":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"e8757048063dc4c3d6af4401220ac23581f2c60c"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"2346e9edaccfc7dd2fa30c970d8d4346a6780ac7"},{"mode":33261,"name":"test.js","hash":"6c9ddafa9ad2b02682081328fe0aadf15002a778"}]},"7ed3c4cf367cfbf19f23f16fb3752987aeb74bcf":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"ec160900fb81d62f0f1d3ec9c242f56a34bb8f9d"},{"mode":33188,"name":"README.markdown","hash":"f8a10a88fc083f43083d0393062dfeddb9b32ae6"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"2346e9edaccfc7dd2fa30c970d8d4346a6780ac7"},{"mode":33261,"name":"test.js","hash":"6c9ddafa9ad2b02682081328fe0aadf15002a778"}]},"eb579ea870af3232f018b87d601dad9d1dbf70bf":{"type":"blob","body":"var msgpack = require('./msgpack');\nvar util = require('util');\nvar assert = require('assert');\n\nvar tests = [\n  true, false, null, undefined,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world', Buffer(\"Hello\"), Buffer(\"World\"),\n  [1,2,3], [], {name: \"Tim\", age: 29}, {},\n  {a: 1, b: 2, c: [1, 2, 3]},\n];\nfor (var i = 0, l = tests.length; i < l; i++) {\n  var test = tests[i];\n  if (typeof test === 'number') {\n    tests.push(test + 1);\n    tests.push(test - 1);\n    tests.push(test + 0.5);\n  }\n}\n[0x100, 0x1000, 0x10000, 0x100000].forEach(function (length) {\n  var list = new Array(length), obj = {};\n  for (var i = 0; i < length; i++) {\n    list[i] = i;\n    obj[i] = i;\n  }\n  tests.push(list);\n  tests.push(obj);\n});\n\nvar width = process.stdout.getWindowSize()[0];\nvar mistakes = 0;\nfunction dump(value) {\n  if (typeof value === 'undefined' || Buffer.isBuffer(value)) {\n    return util.inspect(value).replace(/\\n */g, '');\n  }\n  return JSON.stringify(value);\n}\ntests.forEach(function (test) {\n  console.log(dump(test).substr(0, width));\n  var encoded = msgpack.encode(test);\n  console.log(encoded.inspect().substr(0, width));\n  var decoded = msgpack.decode(encoded);\n  try {\n    assert.deepEqual(test, decoded);\n    if (typeof test === \"object\" && test !== null) {\n      assert.equal(test.constructor, decoded.constructor);\n    }\n  } catch (err) {\n    console.error();\n    console.error(dump(test).substr(0, width));\n    console.error(encoded.inspect().substr(0, width));\n    console.error(dump(decoded).substr(0, width));\n    console.error(err.stack);\n    mistakes++;\n  }\n});\nif (mistakes) {\n  console.error(mistakes + \" tests failed!\");\n} else {\n  console.log(\"\\nAll tests passed successfully!\");\n}\nprocess.exit(mistakes);\n"},"771cbb73f2c9242618472c8049402951674e839a":{"type":"blob","body":"#!/usr/bin/env node\nvar msgpack = require('./msgpack');\nvar util = require('util');\nvar assert = require('assert');\n\nvar tests = [\n  true, false, null, undefined,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world', Buffer(\"Hello\"), Buffer(\"World\"),\n  [1,2,3], [], {name: \"Tim\", age: 29}, {},\n  {a: 1, b: 2, c: [1, 2, 3]},\n];\nfor (var i = 0, l = tests.length; i < l; i++) {\n  var test = tests[i];\n  if (typeof test === 'number') {\n    tests.push(test + 1);\n    tests.push(test - 1);\n    tests.push(test + 0.5);\n  }\n}\n[0x100, 0x1000, 0x10000, 0x100000].forEach(function (length) {\n  var list = new Array(length), obj = {};\n  for (var i = 0; i < length; i++) {\n    list[i] = i;\n    obj[i] = i;\n  }\n  tests.push(list);\n  tests.push(obj);\n});\n\nvar width = process.stdout.getWindowSize()[0];\nvar mistakes = 0;\nfunction dump(value) {\n  if (typeof value === 'undefined' || Buffer.isBuffer(value)) {\n    return util.inspect(value).replace(/\\n */g, '');\n  }\n  return JSON.stringify(value);\n}\ntests.forEach(function (test) {\n  console.log(dump(test).substr(0, width));\n  var encoded = msgpack.encode(test);\n  console.log(encoded.inspect().substr(0, width));\n  var decoded = msgpack.decode(encoded);\n  try {\n    assert.deepEqual(test, decoded);\n    if (typeof test === \"object\" && test !== null) {\n      assert.equal(test.constructor, decoded.constructor);\n    }\n  } catch (err) {\n    console.error();\n    console.error(dump(test).substr(0, width));\n    console.error(encoded.inspect().substr(0, width));\n    console.error(dump(decoded).substr(0, width));\n    console.error(err.stack);\n    mistakes++;\n  }\n});\nif (mistakes) {\n  console.error(mistakes + \" tests failed!\");\n} else {\n  console.log(\"\\nAll tests passed successfully!\");\n}\nprocess.exit(mistakes.length);\n"},"b73b5df0fd85216f583b58f5fae6c5d068134a15":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"072d4e367b7fcdf381a13c3f8f81ad43e15402b8"},{"mode":33188,"name":"README.markdown","hash":"8a0472d5af516253ed72b278ceb46ee64d8606dd"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"96cba8f7c0e8651660dec4edf36b29a9f6a5bf5f"},{"mode":33188,"name":"test.js","hash":"c2f802ed497ac913fdc7e1bf76e5ec66ea4bb19f"}]},"42a0b07edda69c054bb24101493e436483fa5e62":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"072d4e367b7fcdf381a13c3f8f81ad43e15402b8"},{"mode":33188,"name":"README.markdown","hash":"931ccdfc11fb13eea3b97b0e464567157a25368b"},{"mode":33188,"name":"msgpack.js","hash":"9d10683a04eef661cefc6bff3feda6f214bc4ead"},{"mode":33188,"name":"package.json","hash":"96cba8f7c0e8651660dec4edf36b29a9f6a5bf5f"},{"mode":33188,"name":"test.js","hash":"c2f802ed497ac913fdc7e1bf76e5ec66ea4bb19f"}]},"f082a5f07415747dc5f4fe3cbd14606fdf7833a7":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"README.markdown","hash":"931ccdfc11fb13eea3b97b0e464567157a25368b"},{"mode":33188,"name":"msgpack.js","hash":"751945205c169821dc77f30ed6b1c7db7b49b436"},{"mode":33188,"name":"package.json","hash":"96cba8f7c0e8651660dec4edf36b29a9f6a5bf5f"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"8a0472d5af516253ed72b278ceb46ee64d8606dd":{"type":"blob","body":"# msgpack for node\n\n[![node support](https://travis-ci.org/creationix/msgpack-js.png)](https://travis-ci.org/creationix/msgpack-js)\n\n[![browser support](https://ci.testling.com/creationix/msgpack-js.png)](https://ci.testling.com/creationix/msgpack-js)\n\n\nA handwritten msgpack encoder and decoder for Node.JS and modern browsers.\n\nThe original format can be found at <http://wiki.msgpack.org/display/MSGPACK/Format+specification>\n\n\n## Extension\n\nI've extended the format a little to allow for encoding and decoding of `undefined` and `Buffer` instances.\n\nThis required three new type codes that were previously marked as \"reserved\".\nThis change means that using these new types will render your serialized data\nincompatible with other messagepack implementations that don't have the same\nextension.\n\nThere are two new types for storing node `Buffer` instances. These work just \nlike \"raw 16\" and \"raw 32\" except they are node buffers instead of strings.\n\n    buffer 16  11011000  0xd8\n    buffer 32  11011001  0xd9\n\nAlso I've added a type for `undefined` that works just like the `null` type.\n\n    undefined  11000100  0xc4\n\n## Usage\n\n``` javascript\nvar msgpack = require('msgpack');\nvar assert = require('assert');\n\nvar initial = {Hello: \"World\"};\nvar encoded = msgpack.encode(initial);\nvar decoded = msgpack.decode(encoded);\n\nassert.deepEqual(initial, decoded);\n```\n\n"},"96cba8f7c0e8651660dec4edf36b29a9f6a5bf5f":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure javascript\",\n  \"version\": \"0.2.1\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"testling\": {\n    \"files\": \"test.js\",\n    \"browsers\": [\n      \"ie/9..latest\",\n      \"firefox/19..latest\",\n      \"chrome/25..latest\",\n      \"safari/latest\",\n      \"iphone/6\",\n      \"ipad/6\"\n    ]\n  },\n  \"main\": \"msgpack.js\",\n  \"dependencies\": {\n    \"bops\": \"~0.0.6\"\n  },\n  \"devDependencies\": {\n    \"tape\": \"~1.0.2\"\n  }\n}\n"},"befc129d298e6940b0e2c68c20c1532b8a48b87f":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure javascript\",\n  \"version\": \"0.2.1\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"dependencies\": {\n    \"bops\": \"~0.0.6\"\n  },\n  \"devDependencies\": {\n    \"tape\": \"~1.0.2\"\n  },\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"testling\": {\n    \"files\": \"test.js\",\n    \"browsers\": [\n      \"ie/9..latest\",\n      \"firefox/19..latest\",\n      \"chrome/25..latest\",\n      \"safari/latest\",\n      \"iphone/6\",\n      \"ipad/6\"\n    ]\n  }\n}\n"},"ace80691652d73441e2c5ff9e69c872ccad84c67":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js-v5\",\n  \"description\": \"msgpack encoder and decoder in pure javascript based on creationix/msgpack-js updated to match the new v5 specification with string support.\",\n  \"version\": \"0.3.0-v5\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/chakrit/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"dependencies\": {\n    \"bops\": \"~0.0.6\"\n  },\n  \"devDependencies\": {\n    \"tape\": \"~1.0.2\"\n  },\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"testling\": {\n    \"files\": \"test.js\",\n    \"browsers\": [\n      \"ie/9..latest\",\n      \"firefox/19..latest\",\n      \"chrome/25..latest\",\n      \"safari/latest\",\n      \"iphone/6\",\n      \"ipad/6\"\n    ]\n  }\n}\n"},"7db951071bf320f25006a93ca5a6e76c9ee91c72":{"type":"blob","body":"exports.encode = function (value) {\n  var buffer = new Buffer(sizeof(value));\n  encode(value, buffer, 0);\n  return buffer;\n}\n\nexports.decode = decode;\nexports.Decoder = Decoder;\n\n// http://wiki.msgpack.org/display/MSGPACK/Format+specification\n// I've extended the protocol to have two new types that were previously reserved.\n//   buffer 16  11011000  0xd8\n//   buffer 32  11011001  0xd9\n// These work just like raw16 and raw32 except they are node buffers instead of strings.\n//\n// Also I've added a type for `undefined`\n//   undefined  11000100  0xc4\n\nfunction Decoder(buffer, offset) {\n  this.offset = offset || 0;\n  this.buffer = buffer;\n  this.bytesRemaining = buffer.length - this.offset;\n}\nDecoder.prototype.map = function (length) {\n  var value = {};\n  for (var i = 0; i < length; i++) {\n    var key = this.parse();\n    value[key] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.buf = function (length) {\n  var value = this.buffer.slice(this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.raw = function (length) {\n  var value = this.buffer.toString('utf8', this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.array = function (length) {\n  var value = new Array(length);\n  for (var i = 0; i < length; i++) {\n    value[i] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.parse = function () {\n  var type = this.buffer[this.offset];\n  var value, length;\n  // FixRaw\n  if ((type & 0xe0) === 0xa0) {\n    length = type & 0x1f;\n    this.offset++;\n    return this.raw(length);\n  }\n  // FixMap\n  if ((type & 0xf0) === 0x80) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.map(length);\n  }\n  // FixArray\n  if ((type & 0xf0) === 0x90) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.array(length);\n  }\n  // Positive FixNum\n  if ((type & 0x80) === 0x00) {\n    this.offset++;\n    return type;\n  }\n  // Negative Fixnum\n  if ((type & 0xe0) === 0xe0) {\n    value = this.buffer.readInt8(this.offset);\n    this.offset++;\n    return value;\n  }\n  switch (type) {\n  // raw 16\n  case 0xda:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.raw(length);\n  // raw 32\n  case 0xdb:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.raw(length);\n  // nil\n  case 0xc0:\n    this.offset++;\n    return null;\n  // false\n  case 0xc2:\n    this.offset++;\n    return false;\n  // true\n  case 0xc3:\n    this.offset++;\n    return true;\n  // undefined\n  case 0xc4:\n    this.offset++;\n    return undefined;\n  // uint8\n  case 0xcc:\n    value = this.buffer[this.offset + 1];\n    this.offset += 2;\n    return value;\n  // uint 16\n  case 0xcd:\n    value = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return value;\n  // uint 32\n  case 0xce:\n    value = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return value;\n  // uint64\n  case 0xcf:\n    value = this.buffer.readUInt64BE(this.offset + 1);\n    this.offset += 9;\n    return value;\n  // int 8\n  case 0xd0:\n    value = this.buffer.readInt8(this.offset + 1);\n    this.offset += 2;\n    return value;\n  // int 16\n  case 0xd1:\n    value = this.buffer.readInt16BE(this.offset + 1);\n    this.offset += 3;\n    return value;\n  // int 32\n  case 0xd2:\n    value = this.buffer.readInt32BE(this.offset + 1);\n    this.offset += 5;\n    return value;\n  // int 64\n  case 0xd3:\n    value = this.buffer.readInt64BE(this.offset + 1);\n    this.offset += 9;\n    return value;\n  // map 16\n  case 0xde:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.map(length);\n  // map 32\n  case 0xdf:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.map(length);\n  // array 16\n  case 0xdc:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.array(length);\n  // array 32\n  case 0xdd:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.array(length);\n  // buffer 16\n  case 0xd8:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.buf(length);\n  // buffer 32\n  case 0xd9:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.buf(length);\n  // float\n  case 0xca:\n    value = this.buffer.readFloatBE(this.offset + 1);\n    this.offset += 5;\n    return value;\n  // double\n  case 0xcb:\n    value = this.buffer.readDoubleBE(this.offset + 1);\n    this.offset += 9;\n    return value;\n  }\n  throw new Error(\"Unknown type 0x\" + type.toString(16));\n};\nDecoder.prototype.decode = function () {\n  var rv = this.parse();\n  this.bytesRemaining = this.buffer.length - this.offset;\n  return rv;\n};\nfunction decode(buffer) {\n  var decoder = new Decoder(buffer);\n  var value = decoder.parse();\n  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + \" trailing bytes\");\n  return value;\n}\n\nfunction encode(value, buffer, offset) {\n  var type = typeof value;\n\n  // Strings Bytes\n  if (type === \"string\") {\n    var length = Buffer.byteLength(value);\n    // fix raw\n    if (length < 0x20) {\n      buffer[offset] = length | 0xa0;\n      buffer.write(value, offset + 1);\n      return 1 + length;\n    }\n    // raw 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xda;\n      buffer.writeUInt16BE(length, offset + 1);\n      buffer.write(value, offset + 3);\n      return 3 + length;\n    }\n    // raw 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xdb;\n      buffer.writeUInt32BE(length, offset + 1);\n      buffer.write(value, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (Buffer.isBuffer(value)) {\n    var length = value.length;\n    // buffer 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xd8;\n      buffer.writeUInt16BE(length, offset + 1);\n      value.copy(buffer, offset + 3);\n      return 3 + length;\n    }\n    // buffer 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xd9;\n      buffer.writeUInt32BE(length, offset + 1);\n      value.copy(buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n  \n  if (type === \"number\") {\n    // Floating Point\n    if ((value << 0) !== value) {\n      buffer[offset] =  0xcb;\n      buffer.writeDoubleBE(value, offset + 1);\n      return 9;\n    }\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) {\n        buffer[offset] = value;\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        buffer[offset] = 0xcc;\n        buffer[offset + 1] = value;\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        buffer[offset] = 0xcd;\n        buffer.writeUInt16BE(value, offset + 1);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        buffer[offset] = 0xce;\n        buffer.writeUInt32BE(value, offset + 1);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        buffer[offset] = 0xcf;\n        buffer.writeUInt64BE(value, offset + 1);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) {\n      buffer.writeInt8(value, offset);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      buffer[offset] = 0xd0;\n      buffer.writeInt8(value, offset + 1);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      buffer[offset] = 0xd1;\n      buffer.writeInt16BE(value, offset + 1);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      buffer[offset] = 0xd2;\n      buffer.writeInt32BE(value, offset + 1);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      buffer[offset] = 0xd3;\n      buffer.writeInt64BE(value, offset + 1);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  \n  // undefined\n  if (type === \"undefined\") {\n    buffer[offset] = 0xc4;\n    return 1;\n  }\n  \n  // null\n  if (value === null) {\n    buffer[offset] = 0xc0;\n    return 1;\n  }\n\n  // Boolean\n  if (type === \"boolean\") {\n    buffer[offset] = value ? 0xc3 : 0xc2;\n    return 1;\n  }\n  \n  // Container Types\n  if (type === \"object\") {\n    var length, size = 0;\n    var isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = value.length;\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n    }\n\n    var size;\n    if (length < 0x10) {\n      buffer[offset] = length | (isArray ? 0x90 : 0x80);\n      size = 1;\n    }\n    else if (length < 0x10000) {\n      buffer[offset] = isArray ? 0xdc : 0xde;\n      buffer.writeUInt16BE(length, offset + 1);\n      size = 3;\n    }\n    else if (length < 0x100000000) {\n      buffer[offset] = isArray ? 0xdd : 0xdf;\n      buffer.writeUInt32BE(length, offset + 1);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (var i = 0; i < length; i++) {\n        size += encode(value[i], buffer, offset + size);\n      }\n    }\n    else {\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += encode(key, buffer, offset + size);\n        size += encode(value[key], buffer, offset + size);\n      }\n    }\n    \n    return size;\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction sizeof(value) {\n  var type = typeof value;\n\n  // Raw Bytes\n  if (type === \"string\") {\n    var length = Buffer.byteLength(value);\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n  \n  if (Buffer.isBuffer(value)) {\n    var length = value.length;\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n  \n  if (type === \"number\") {\n    // Floating Point\n    // double\n    if (value << 0 !== value) return 9;\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  \n  // Boolean, null, undefined\n  if (type === \"boolean\" || type === \"undefined\" || value === null) return 1;\n  \n  // Container Types\n  if (type === \"object\") {\n    var length, size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (var i = 0; i < length; i++) {\n        size += sizeof(value[i]);\n      }\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += sizeof(key) + sizeof(value[key]);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\n"},"9d10683a04eef661cefc6bff3feda6f214bc4ead":{"type":"blob","body":"\"use strict\";\n\nvar bops = require('bops');\n\nexports.encode = function (value) {\n  var buffer = bops.create(sizeof(value));\n  encode(value, buffer, 0);\n  return buffer;\n};\n\nexports.decode = decode;\n\n// http://wiki.msgpack.org/display/MSGPACK/Format+specification\n// I've extended the protocol to have two new types that were previously reserved.\n//   buffer 16  11011000  0xd8\n//   buffer 32  11011001  0xd9\n// These work just like raw16 and raw32 except they are node buffers instead of strings.\n//\n// Also I've added a type for `undefined`\n//   undefined  11000100  0xc4\n\nfunction Decoder(buffer, offset) {\n  this.offset = offset || 0;\n  this.buffer = buffer;\n}\nDecoder.prototype.map = function (length) {\n  var value = {};\n  for (var i = 0; i < length; i++) {\n    var key = this.parse();\n    value[key] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.buf = function (length) {\n  var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.raw = function (length) {\n  var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.array = function (length) {\n  var value = new Array(length);\n  for (var i = 0; i < length; i++) {\n    value[i] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.parse = function () {\n  var type = this.buffer[this.offset];\n  var value, length;\n  // FixRaw\n  if ((type & 0xe0) === 0xa0) {\n    length = type & 0x1f;\n    this.offset++;\n    return this.raw(length);\n  }\n  // FixMap\n  if ((type & 0xf0) === 0x80) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.map(length);\n  }\n  // FixArray\n  if ((type & 0xf0) === 0x90) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.array(length);\n  }\n  // Positive FixNum\n  if ((type & 0x80) === 0x00) {\n    this.offset++;\n    return type;\n  }\n  // Negative Fixnum\n  if ((type & 0xe0) === 0xe0) {\n    value = bops.readInt8(this.buffer, this.offset);\n    this.offset++;\n    return value;\n  }\n  switch (type) {\n  // raw 16\n  case 0xda:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.raw(length);\n  // raw 32\n  case 0xdb:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.raw(length);\n  // nil\n  case 0xc0:\n    this.offset++;\n    return null;\n  // false\n  case 0xc2:\n    this.offset++;\n    return false;\n  // true\n  case 0xc3:\n    this.offset++;\n    return true;\n  // undefined\n  case 0xc4:\n    this.offset++;\n    return undefined;\n  // uint8\n  case 0xcc:\n    value = this.buffer[this.offset + 1];\n    this.offset += 2;\n    return value;\n  // uint 16\n  case 0xcd:\n    value = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // uint 32\n  case 0xce:\n    value = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // uint64\n  case 0xcf:\n    value = bops.readUInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // int 8\n  case 0xd0:\n    value = bops.readInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return value;\n  // int 16\n  case 0xd1:\n    value = bops.readInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // int 32\n  case 0xd2:\n    value = bops.readInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // int 64\n  case 0xd3:\n    value = bops.readInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // map 16\n  case 0xde:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.map(length);\n  // map 32\n  case 0xdf:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.map(length);\n  // array 16\n  case 0xdc:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.array(length);\n  // array 32\n  case 0xdd:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.array(length);\n  // buffer 16\n  case 0xd8:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.buf(length);\n  // buffer 32\n  case 0xd9:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.buf(length);\n  // float\n  case 0xca:\n    value = bops.readFloatBE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // double\n  case 0xcb:\n    value = bops.readDoubleBE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  }\n  throw new Error(\"Unknown type 0x\" + type.toString(16));\n};\nfunction decode(buffer) {\n  var decoder = new Decoder(buffer);\n  var value = decoder.parse();\n  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + \" trailing bytes\");\n  return value;\n}\n\nfunction encode(value, buffer, offset) {\n  var type = typeof value;\n  var length, size;\n\n  // Strings Bytes\n  if (type === \"string\") {\n    value = bops.from(value);\n    length = value.length;\n    // fix raw\n    if (length < 0x20) {\n      buffer[offset] = length | 0xa0;\n      bops.copy(value, buffer, offset + 1);\n      return 1 + length;\n    }\n    // raw 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xda;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // raw 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xdb;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    // buffer 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xd8;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // buffer 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xd9;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    if ((value << 0) !== value) {\n      buffer[offset] =  0xcb;\n      bops.writeDoubleBE(buffer, value, offset + 1);\n      return 9;\n    }\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) {\n        buffer[offset] = value;\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        buffer[offset] = 0xcc;\n        buffer[offset + 1] = value;\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        buffer[offset] = 0xcd;\n        bops.writeUInt16BE(buffer, value, offset + 1);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        buffer[offset] = 0xce;\n        bops.writeUInt32BE(buffer, value, offset + 1);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        buffer[offset] = 0xcf;\n        bops.writeUInt64BE(buffer, value, offset + 1);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) {\n      bops.writeInt8(buffer, value, offset);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      buffer[offset] = 0xd0;\n      bops.writeInt8(buffer, value, offset + 1);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      buffer[offset] = 0xd1;\n      bops.writeInt16BE(buffer, value, offset + 1);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      buffer[offset] = 0xd2;\n      bops.writeInt32BE(buffer, value, offset + 1);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      buffer[offset] = 0xd3;\n      bops.writeInt64BE(buffer, value, offset + 1);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  // undefined\n  if (type === \"undefined\") {\n    buffer[offset] = 0xc4;\n    return 1;\n  }\n\n  // null\n  if (value === null) {\n    buffer[offset] = 0xc0;\n    return 1;\n  }\n\n  // Boolean\n  if (type === \"boolean\") {\n    buffer[offset] = value ? 0xc3 : 0xc2;\n    return 1;\n  }\n\n  // Container Types\n  if (type === \"object\") {\n    size = 0;\n    var isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = value.length;\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n    }\n\n    if (length < 0x10) {\n      buffer[offset] = length | (isArray ? 0x90 : 0x80);\n      size = 1;\n    }\n    else if (length < 0x10000) {\n      buffer[offset] = isArray ? 0xdc : 0xde;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      size = 3;\n    }\n    else if (length < 0x100000000) {\n      buffer[offset] = isArray ? 0xdd : 0xdf;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (var i = 0; i < length; i++) {\n        size += encode(value[i], buffer, offset + size);\n      }\n    }\n    else {\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += encode(key, buffer, offset + size);\n        size += encode(value[key], buffer, offset + size);\n      }\n    }\n\n    return size;\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction sizeof(value) {\n  var type = typeof value;\n  var length, size;\n\n  // Raw Bytes\n  if (type === \"string\") {\n    // TODO: this creates a throw-away buffer which is probably expensive on browsers.\n    length = bops.from(value).length;\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    // double\n    if (value << 0 !== value) return 9;\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  // Boolean, null, undefined\n  if (type === \"boolean\" || type === \"undefined\" || value === null) return 1;\n\n  // Container Types\n  if (type === \"object\") {\n    size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (var i = 0; i < length; i++) {\n        size += sizeof(value[i]);\n      }\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += sizeof(key) + sizeof(value[key]);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\n\n"},"82b56e0277afa2dfddd31bfe3dd9512d81ac76b4":{"type":"blob","body":"\"use strict\";\n\nvar bops = require('bops');\n\nexports.encode = function (value) {\n  var toJSONed = []\n  var size = sizeof(value)\n  if(size == 0)\n    return undefined\n  var buffer = bops.create(size);\n  encode(value, buffer, 0);\n  return buffer;\n};\n\nexports.decode = decode;\n\n// https://gist.github.com/frsyuki/5432559 - v5 spec\n//\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\n// should translate to exactly 0xd40000 \n//\n// +--------+--------+--------+\n// |  0xd4  |  0x00  |  0x00  |\n// +--------+--------+--------+\n//    ^ fixext |        ^ value part unused (fixed to be 0)\n//             ^ indicates undefined value\n//\n\nfunction Decoder(buffer, offset) {\n  this.offset = offset || 0;\n  this.buffer = buffer;\n}\nDecoder.prototype.map = function (length) {\n  var value = {};\n  for (var i = 0; i < length; i++) {\n    var key = this.parse();\n    value[key] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.bin = function (length) {\n  var value = bops.subarray(this.buffer, this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.str = function (length) {\n  var value = bops.to(bops.subarray(this.buffer, this.offset, this.offset + length));\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.array = function (length) {\n  var value = new Array(length);\n  for (var i = 0; i < length; i++) {\n    value[i] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.parse = function () {\n  var type = this.buffer[this.offset];\n  var value, length, extType;\n  // Positive FixInt\n  if ((type & 0x80) === 0x00) {\n    this.offset++;\n    return type;\n  }\n  // FixMap\n  if ((type & 0xf0) === 0x80) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.map(length);\n  }\n  // FixArray\n  if ((type & 0xf0) === 0x90) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.array(length);\n  }\n  // FixStr\n  if ((type & 0xe0) === 0xa0) {\n    length = type & 0x1f;\n    this.offset++;\n    return this.str(length);\n  }\n  // Negative FixInt\n  if ((type & 0xe0) === 0xe0) {\n    value = bops.readInt8(this.buffer, this.offset);\n    this.offset++;\n    return value;\n  }\n  switch (type) {\n  // nil\n  case 0xc0:\n    this.offset++;\n    return null;\n  // 0xc1: (never used)\n  // false\n  case 0xc2:\n    this.offset++;\n    return false;\n  // true\n  case 0xc3:\n    this.offset++;\n    return true;\n  // bin 8\n  case 0xc4:\n    length = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return this.bin(length);\n  // bin 16\n  case 0xc5:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.bin(length);\n  // bin 32\n  case 0xc6:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.bin(length);\n  // ext 8\n  case 0xc7:\n    length = bops.readUInt8(this.buffer, this.offset + 1);\n    extType = bops.readUInt8(this.buffer, this.offset + 2);\n    this.offset += 3;\n    return [extType, this.bin(length)];\n  // ext 16\n  case 0xc8:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    extType = bops.readUInt8(this.buffer, this.offset + 3);\n    this.offset += 4;\n    return [extType, this.bin(length)];\n  // ext 32\n  case 0xc9:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    extType = bops.readUInt8(this.buffer, this.offset + 5);\n    this.offset += 6;\n    return [extType, this.bin(length)];\n  // float 32\n  case 0xca:\n    value = bops.readFloatBE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // float 64 / double\n  case 0xcb:\n    value = bops.readDoubleBE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // uint8\n  case 0xcc:\n    value = this.buffer[this.offset + 1];\n    this.offset += 2;\n    return value;\n  // uint 16\n  case 0xcd:\n    value = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // uint 32\n  case 0xce:\n    value = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // uint64\n  case 0xcf:\n    value = bops.readUInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n  // int 8\n  case 0xd0:\n    value = bops.readInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return value;\n  // int 16\n  case 0xd1:\n    value = bops.readInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return value;\n  // int 32\n  case 0xd2:\n    value = bops.readInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return value;\n  // int 64\n  case 0xd3:\n    value = bops.readInt64BE(this.buffer, this.offset + 1);\n    this.offset += 9;\n    return value;\n\n  // fixext 1 / undefined\n  case 0xd4:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    value = bops.readUInt8(this.buffer, this.offset + 2);\n    this.offset += 3;\n    return (extType === 0 && value === 0) ? undefined : [extType, value];\n  // fixext 2\n  case 0xd5:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(2)];\n  // fixext 4\n  case 0xd6:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(4)];\n  // fixext 8\n  case 0xd7:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(8)];\n  // fixext 16\n  case 0xd8:\n    extType = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return [extType, this.bin(16)];\n  // str 8\n  case 0xd9:\n    length = bops.readUInt8(this.buffer, this.offset + 1);\n    this.offset += 2;\n    return this.str(length);\n  // str 16\n  case 0xda:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.str(length);\n  // str 32\n  case 0xdb:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.str(length);\n  // array 16\n  case 0xdc:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.array(length);\n  // array 32\n  case 0xdd:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.array(length);\n  // map 16:\n  case 0xde:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.map(length);\n  // map 32\n  case 0xdf:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.map(length);\n  // buffer 16\n  case 0xd8:\n    length = bops.readUInt16BE(this.buffer, this.offset + 1);\n    this.offset += 3;\n    return this.buf(length);\n  // buffer 32\n  case 0xd9:\n    length = bops.readUInt32BE(this.buffer, this.offset + 1);\n    this.offset += 5;\n    return this.buf(length);\n  }\n\n  throw new Error(\"Unknown type 0x\" + type.toString(16));\n};\nfunction decode(buffer) {\n  var decoder = new Decoder(buffer);\n  var value = decoder.parse();\n  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + \" trailing bytes\");\n  return value;\n}\n\nfunction encodeableKeys (value) {\n  return Object.keys(value).filter(function (e) {\n    return 'function' !== typeof value[e] || !!value[e].toJSON\n  })\n}\n\nfunction encode(value, buffer, offset) {\n  var type = typeof value;\n  var length, size;\n\n  // Strings Bytes\n  if (type === \"string\") {\n    value = bops.from(value);\n    length = value.length;\n    // fixstr\n    if (length < 0x20) {\n      buffer[offset] = length | 0xa0;\n      bops.copy(value, buffer, offset + 1);\n      return 1 + length;\n    }\n    // str 8\n    if (length < 0x100) {\n      buffer[offset] = 0xd9;\n      bops.writeUInt8(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 2);\n      return 2 + length;\n    }\n    // str 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xda;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // str 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xdb;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    // bin 8\n    if (length < 0x100) {\n      buffer[offset] = 0xc4;\n      bops.writeUInt8(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 2);\n      return 2 + length;\n    }\n    // bin 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xd8;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 3);\n      return 3 + length;\n    }\n    // bin 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xd9;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      bops.copy(value, buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    if ((value << 0) !== value) {\n      buffer[offset] =  0xcb;\n      bops.writeDoubleBE(buffer, value, offset + 1);\n      return 9;\n    }\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) {\n        buffer[offset] = value;\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        buffer[offset] = 0xcc;\n        buffer[offset + 1] = value;\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        buffer[offset] = 0xcd;\n        bops.writeUInt16BE(buffer, value, offset + 1);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        buffer[offset] = 0xce;\n        bops.writeUInt32BE(buffer, value, offset + 1);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        buffer[offset] = 0xcf;\n        bops.writeUInt64BE(buffer, value, offset + 1);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) {\n      bops.writeInt8(buffer, value, offset);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      buffer[offset] = 0xd0;\n      bops.writeInt8(buffer, value, offset + 1);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      buffer[offset] = 0xd1;\n      bops.writeInt16BE(buffer, value, offset + 1);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      buffer[offset] = 0xd2;\n      bops.writeInt32BE(buffer, value, offset + 1);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      buffer[offset] = 0xd3;\n      bops.writeInt64BE(buffer, value, offset + 1);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  if (type === \"undefined\") {\n    buffer[offset] = 0xd4;\n    buffer[offset + 1] = 0x00; // fixext special type/value\n    buffer[offset + 2] = 0x00;\n    return 1;\n  }\n\n  // null\n  if (value === null) {\n    buffer[offset] = 0xc0;\n    return 1;\n  }\n\n  // Boolean\n  if (type === \"boolean\") {\n    buffer[offset] = value ? 0xc3 : 0xc2;\n    return 1;\n  }\n\n  if('function' === typeof value.toJSON)\n    return encode(value.toJSON(), buffer, offset)\n\n  // Container Types\n  if (type === \"object\") {\n\n    size = 0;\n    var isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = value.length;\n    }\n    else {\n      var keys = encodeableKeys(value)\n      length = keys.length;\n    }\n\n    // fixarray\n    if (length < 0x10) {\n      buffer[offset] = length | (isArray ? 0x90 : 0x80);\n      size = 1;\n    }\n    // array 16 / map 16\n    else if (length < 0x10000) {\n      buffer[offset] = isArray ? 0xdc : 0xde;\n      bops.writeUInt16BE(buffer, length, offset + 1);\n      size = 3;\n    }\n    // array 32 / map 32\n    else if (length < 0x100000000) {\n      buffer[offset] = isArray ? 0xdd : 0xdf;\n      bops.writeUInt32BE(buffer, length, offset + 1);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (var i = 0; i < length; i++) {\n        size += encode(value[i], buffer, offset + size);\n      }\n    }\n    else {\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += encode(key, buffer, offset + size);\n        size += encode(value[key], buffer, offset + size);\n      }\n    }\n\n    return size;\n  }\n  if(type === \"function\")\n    return undefined\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction sizeof(value) {\n  var type = typeof value;\n  var length, size;\n\n  // Raw Bytes\n  if (type === \"string\") {\n    // TODO: this creates a throw-away buffer which is probably expensive on browsers.\n    length = bops.from(value).length;\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (bops.is(value)) {\n    length = value.length;\n    if (length < 0x100) {\n      return 2 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n\n  if (type === \"number\") {\n    // Floating Point\n    // double\n    if (value << 0 !== value) return 9;\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n\n  // Boolean, null\n  if (type === \"boolean\" || value === null) return 1;\n  if (type === 'undefined') return 3;\n\n  if('function' === typeof value.toJSON)\n    return sizeof(value.toJSON())\n\n  // Container Types\n  if (type === \"object\") {\n    if('function' === typeof value.toJSON)\n      value = value.toJSON()\n\n    size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (var i = 0; i < length; i++) {\n        size += sizeof(value[i]);\n      }\n    }\n    else {\n      var keys = encodeableKeys(value)\n      length = keys.length;\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += sizeof(key) + sizeof(value[key]);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  if(type === \"function\")\n    return 0\n  throw new Error(\"Unknown type \" + type);\n}\n\n\n"},"a509d24ccb90ed16a6cc196501e9d78638f652f4":{"type":"blob","body":"# MSGPACK-JS-V5\n\n**Please see the [original README.md][1] from the source repository for more\ninformation.**\n\nThis is a port of [creationix/msgpack-js][0] to support the new MsgPack v5\nspecification.\n\n* New spec: https://github.com/msgpack/msgpack/blob/master/spec.md\n* Old spec: https://github.com/msgpack/msgpack/blob/master/spec-old.md\n\nPlease feel free to open issues/pull requests for support/discussion.\n\n# INSTALL\n\n```sh\n$ npm i msgpack-js-v5 --save\n```\n\n# EXTENSION\n\nSince there is no way to encode `undefined` inside the msgpack spec, an extension point i\nused for this purpose.\n\nSpecifically, the `fixext 1` type is used with all values being 0 to indicate undefined.\nOn the wire, it requires 3 bytes and should looks like this:\n\n```\n0xd4 | 0x00 | 0x00\n```\n\nWhere `|` is byte separator.\n\n# VERSIONING\n\nThis package will follows `msgpack-js` version for the time being. The version string will\nsimply be appended with `v5`.\n\nIf and when this package diverges from the original, we can start our own versioning. Or\nthis module could just be merged into the original `msgpack-js` module.\n\n"},"bb77e036ef7c2ff058264b2e14f0c0f67ecadc84":{"type":"blob","body":"# MSGPACK-JS-V5\n\n**Please see the [original README.md][1] from the source repository for more\ninformation.**\n\nThis is a port of [creationix/msgpack-js][0] to support the new MsgPack v5\nspecification.\n\n* New spec: https://github.com/msgpack/msgpack/blob/master/spec.md\n* Old spec: https://github.com/msgpack/msgpack/blob/master/spec-old.md\n\nPlease feel free to open issues/pull requests for support/discussion.\n\n# INSTALL\n\n```sh\n$ npm i msgpack-js-v5 --save\n```\n\n# EXTENSION\n\nSince there is no way to encode `undefined` inside the msgpack spec, an extension point is\nused for this purpose. Specifically, the `fixext 1` type is used with all values being 0\nto indicate `undefined`. On the wire, it requires 3 bytes and should looks like this:\n\n```\n0xd4 | 0x00 | 0x00\n```\n\nWhere `|` is byte separator.\n\n# EXT / FIXEXT\n\nExtensions are encoded/decoded to and from a simple 2-elements array tuple of the form\n`[type, Buffer]`. Where `type` is the msgpack extension type identifier and `Buffer` is\nthe raw decoded value.\n\nSpecial case for `fixext 1` since it will always be 1-byte long a simple `[type, value]`\nis returned directly instead of wrapping it in node.js `Buffer`.\n\n# VERSIONING\n\nThis package will follows `msgpack-js` version for the time being. The version string will\nsimply be appended with `v5`.\n\nIf and when this package diverges from the original, we can start our own versioning. Or\nthis module could just be merged into the original `msgpack-js` module.\n\n [0]: https://github.com/creationix/msgpack-js\n [1]: https://github.com/creationix/msgpack-js/blob/master/README.markdown\n\n"},"238443d8beae512a0a70480fe7d422c2aecdf02e":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"README.markdown","hash":"931ccdfc11fb13eea3b97b0e464567157a25368b"},{"mode":33188,"name":"msgpack.js","hash":"82b56e0277afa2dfddd31bfe3dd9512d81ac76b4"},{"mode":33188,"name":"package.json","hash":"1ceb7e8e4c2404f05f2c17e1ac73f0916bda03e6"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"205900fa32640820ceab3e40fa8d1a2698a1cdd1":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"README.markdown","hash":"931ccdfc11fb13eea3b97b0e464567157a25368b"},{"mode":33188,"name":"msgpack.js","hash":"751945205c169821dc77f30ed6b1c7db7b49b436"},{"mode":33188,"name":"package.json","hash":"befc129d298e6940b0e2c68c20c1532b8a48b87f"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"b9d9a184cdea67619f3607fc29ec0009a4b5142d":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"AUTHORS","hash":"018aa78d34cb1506698f979f181bebbc231916df"},{"mode":33188,"name":"README.markdown","hash":"bb77e036ef7c2ff058264b2e14f0c0f67ecadc84"},{"mode":33188,"name":"msgpack.js","hash":"82b56e0277afa2dfddd31bfe3dd9512d81ac76b4"},{"mode":33188,"name":"package.json","hash":"ace80691652d73441e2c5ff9e69c872ccad84c67"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"804bf23ae67d25986e6e24f47fd697b11fc0602d":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"AUTHORS","hash":"018aa78d34cb1506698f979f181bebbc231916df"},{"mode":33188,"name":"README.markdown","hash":"a509d24ccb90ed16a6cc196501e9d78638f652f4"},{"mode":33188,"name":"msgpack.js","hash":"82b56e0277afa2dfddd31bfe3dd9512d81ac76b4"},{"mode":33188,"name":"package.json","hash":"ace80691652d73441e2c5ff9e69c872ccad84c67"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"892bd68b4e95606b455f5ecbf3d44cfa49d4c8cd":{"type":"tree","body":[{"mode":33188,"name":".travis.yml","hash":"8f4f27933b8e075c612260b90e40f2bd903eb403"},{"mode":33188,"name":"AUTHORS","hash":"018aa78d34cb1506698f979f181bebbc231916df"},{"mode":33188,"name":"README.markdown","hash":"b51533d02f7e1ce083604a77d07dd61cbf56e0e8"},{"mode":33188,"name":"msgpack.js","hash":"82b56e0277afa2dfddd31bfe3dd9512d81ac76b4"},{"mode":33188,"name":"package.json","hash":"0f764dcab3fbc2aa8b4c40b0dbcaa6bbe9e0cd93"},{"mode":33188,"name":"test.js","hash":"afac7827b2a67af53108cede75cb0312edbeec58"}]},"b51533d02f7e1ce083604a77d07dd61cbf56e0e8":{"type":"blob","body":"# MSGPACK-JS-V5\n\n**Please see the [original README.md][1] from the source repository for more\ninformation.**\n\nThis is a port of [creationix/msgpack-js][0] to support the new MsgPack v5\nspecification.\n\n* New spec: https://github.com/msgpack/msgpack/blob/master/spec.md\n* Old spec: https://github.com/msgpack/msgpack/blob/master/spec-old.md\n\nPlease feel free to open issues/pull requests for support/discussion.\n\n# INSTALL\n\n```sh\n$ npm i msgpack-js-v5 --save\n```\n\n# EXTENSION\n\nSince there is no way to encode `undefined` inside the msgpack spec, an extension point i\nused for this purpose.\n\nSpecifically, the `fixext 1` type is used with all values being 0 to indicate undefined.\nOn the wire, it requires 3 bytes and should looks like this:\n\n```\n0xd4 | 0x00 | 0x00\n```\n\nWhere `|` is byte separator.\n\n"},"bb2bb759c65d460689172b2abf74cef257848786":{"type":"blob","body":"exports.encode = function (value) {\n  var buffer = new Buffer(sizeof(value));\n  encode(value, buffer, 0);\n  return buffer;\n}\n\nexports.decode = decode;\n\n// http://wiki.msgpack.org/display/MSGPACK/Format+specification\n// I've extended the protocol to have two new types that were previously reserved.\n//   buffer 16  11011000  0xd8\n//   buffer 32  11011001  0xd9\n// These work just like raw16 and raw32 except they are node buffers instead of strings.\n//\n// Also I've added a type for `undefined`\n//   undefined  11000100  0xc4\n\nfunction Decoder(buffer, offset) {\n  this.offset = offset || 0;\n  this.buffer = buffer;\n}\nDecoder.prototype.map = function (length) {\n  var value = {};\n  for (var i = 0; i < length; i++) {\n    var key = this.parse();\n    value[key] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.buf = function (length) {\n  var value = this.buffer.slice(this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.raw = function (length) {\n  var value = this.buffer.toString('utf8', this.offset, this.offset + length);\n  this.offset += length;\n  return value;\n};\nDecoder.prototype.array = function (length) {\n  var value = new Array(length);\n  for (var i = 0; i < length; i++) {\n    value[i] = this.parse();\n  }\n  return value;\n};\nDecoder.prototype.parse = function () {\n  var type = this.buffer[this.offset];\n  var value, length;\n  // FixRaw\n  if ((type & 0xe0) === 0xa0) {\n    length = type & 0x1f;\n    this.offset++;\n    return this.raw(length);\n  }\n  // FixMap\n  if ((type & 0xf0) === 0x80) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.map(length);\n  }\n  // FixArray\n  if ((type & 0xf0) === 0x90) {\n    length = type & 0x0f;\n    this.offset++;\n    return this.array(length);\n  }\n  // Positive FixNum\n  if ((type & 0x80) === 0x00) {\n    this.offset++;\n    return type;\n  }\n  // Negative Fixnum\n  if ((type & 0xe0) === 0xe0) {\n    value = this.buffer.readInt8(this.offset);\n    this.offset++;\n    return value;\n  }\n  switch (type) {\n  // raw 16\n  case 0xda:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.raw(length);\n  // raw 32\n  case 0xdb:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.raw(length);\n  // nil\n  case 0xc0:\n    this.offset++;\n    return null;\n  // false\n  case 0xc2:\n    this.offset++;\n    return false;\n  // true\n  case 0xc3:\n    this.offset++;\n    return true;\n  // undefined\n  case 0xc4:\n    this.offset++;\n    return undefined;\n  // uint8\n  case 0xcc:\n    value = this.buffer[this.offset + 1];\n    this.offset += 2;\n    return value;\n  // uint 16\n  case 0xcd:\n    value = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return value;\n  // uint 32\n  case 0xce:\n    value = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return value;\n  // uint64\n  case 0xcf:\n    value = this.buffer.readUInt64BE(this.offset + 1);\n    this.offset += 9;\n    return value;\n  // int 8\n  case 0xd0:\n    value = this.buffer.readInt8(this.offset + 1);\n    this.offset += 2;\n    return value;\n  // int 16\n  case 0xd1:\n    value = this.buffer.readInt16BE(this.offset + 1);\n    this.offset += 3;\n    return value;\n  // int 32\n  case 0xd2:\n    value = this.buffer.readInt32BE(this.offset + 1);\n    this.offset += 5;\n    return value;\n  // int 64\n  case 0xd3:\n    value = this.buffer.readInt64BE(this.offset + 1);\n    this.offset += 9;\n    return value;\n  // map 16\n  case 0xde:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.map(length);\n  // map 32\n  case 0xdf:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.map(length);\n  // array 16\n  case 0xdc:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.array(length);\n  // array 32\n  case 0xdd:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.array(length);\n  // buffer 16\n  case 0xd8:\n    length = this.buffer.readUInt16BE(this.offset + 1);\n    this.offset += 3;\n    return this.buf(length);\n  // buffer 32\n  case 0xd9:\n    length = this.buffer.readUInt32BE(this.offset + 1);\n    this.offset += 5;\n    return this.buf(length);\n  // float\n  case 0xca:\n    value = this.buffer.readFloatBE(this.offset + 1);\n    this.offset += 5;\n    return value;\n  // double\n  case 0xcb:\n    value = this.buffer.readDoubleBE(this.offset + 1);\n    this.offset += 9;\n    return value;\n  }\n  throw new Error(\"Unknown type 0x\" + type.toString(16));\n};\nfunction decode(buffer) {\n  var decoder = new Decoder(buffer);\n  var value = decoder.parse();\n  if (decoder.offset !== buffer.length) throw new Error((buffer.length - decoder.offset) + \" trailing bytes\");\n  return value;\n}\n\nfunction encode(value, buffer, offset) {\n  var type = typeof value;\n\n  // Strings Bytes\n  if (type === \"string\") {\n    var length = Buffer.byteLength(value);\n    // fix raw\n    if (length < 0x20) {\n      buffer[offset] = length | 0xa0;\n      buffer.write(value, offset + 1);\n      return 1 + length;\n    }\n    // raw 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xda;\n      buffer.writeUInt16BE(length, offset + 1);\n      buffer.write(value, offset + 3);\n      return 3 + length;\n    }\n    // raw 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xdb;\n      buffer.writeUInt32BE(length, offset + 1);\n      buffer.write(value, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (Buffer.isBuffer(value)) {\n    var length = value.length;\n    // buffer 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xd8;\n      buffer.writeUInt16BE(length, offset + 1);\n      value.copy(buffer, offset + 3);\n      return 3 + length;\n    }\n    // buffer 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xd9;\n      buffer.writeUInt32BE(length, offset + 1);\n      value.copy(buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n  \n  if (type === \"number\") {\n    // Floating Point\n    if ((value << 0) !== value) {\n      buffer[offset] =  0xcb;\n      buffer.writeDoubleBE(value, offset + 1);\n      return 9;\n    }\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) {\n        buffer[offset] = value;\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        buffer[offset] = 0xcc;\n        buffer[offset + 1] = value;\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        buffer[offset] = 0xcd;\n        buffer.writeUInt16BE(value, offset + 1);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        buffer[offset] = 0xce;\n        buffer.writeUInt32BE(value, offset + 1);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        buffer[offset] = 0xcf;\n        buffer.writeUInt64BE(value, offset + 1);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) {\n      buffer.writeInt8(value, offset);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      buffer[offset] = 0xd0;\n      buffer.writeInt8(value, offset + 1);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      buffer[offset] = 0xd1;\n      buffer.writeInt16BE(value, offset + 1);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      buffer[offset] = 0xd2;\n      buffer.writeInt32BE(value, offset + 1);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      buffer[offset] = 0xd3;\n      buffer.writeInt64BE(value, offset + 1);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  \n  // undefined\n  if (type === \"undefined\") {\n    buffer[offset] = 0xc4;\n    return 1;\n  }\n  \n  // null\n  if (value === null) {\n    buffer[offset] = 0xc0;\n    return 1;\n  }\n\n  // Boolean\n  if (type === \"boolean\") {\n    buffer[offset] = value ? 0xc3 : 0xc2;\n    return 1;\n  }\n  \n  // Container Types\n  if (type === \"object\") {\n    var length, size = 0;\n    var isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = value.length;\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n    }\n\n    var size;\n    if (length < 0x10) {\n      buffer[offset] = length | (isArray ? 0x90 : 0x80);\n      size = 1;\n    }\n    else if (length < 0x10000) {\n      buffer[offset] = isArray ? 0xdc : 0xde;\n      buffer.writeUInt16BE(length, offset + 1);\n      size = 3;\n    }\n    else if (length < 0x100000000) {\n      buffer[offset] = isArray ? 0xdd : 0xdf;\n      buffer.writeUInt32BE(length, offset + 1);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (var i = 0; i < length; i++) {\n        size += encode(value[i], buffer, offset + size);\n      }\n    }\n    else {\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += encode(key, buffer, offset + size);\n        size += encode(value[key], buffer, offset + size);\n      }\n    }\n    \n    return size;\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction sizeof(value) {\n  var type = typeof value;\n\n  // Raw Bytes\n  if (type === \"string\") {\n    var length = Buffer.byteLength(value);\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n  \n  if (Buffer.isBuffer(value)) {\n    var length = value.length;\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n  \n  if (type === \"number\") {\n    // Floating Point\n    // double\n    if (value << 0 !== value) return 9;\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  \n  // Boolean, null, undefined\n  if (type === \"boolean\" || type === \"undefined\" || value === null) return 1;\n  \n  // Container Types\n  if (type === \"object\") {\n    var length, size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (var i = 0; i < length; i++) {\n        size += sizeof(value[i]);\n      }\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += sizeof(key) + sizeof(value[key]);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\n\n"},"0f764dcab3fbc2aa8b4c40b0dbcaa6bbe9e0cd93":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js-v5\",\n  \"description\": \"msgpack encoder and decoder in pure javascript based on creationix/msgpack-js updated to match the new v5 specification with string support.\",\n  \"version\": \"0.1.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/chakrit/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"dependencies\": {\n    \"bops\": \"~0.0.6\"\n  },\n  \"devDependencies\": {\n    \"tape\": \"~1.0.2\"\n  },\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"testling\": {\n    \"files\": \"test.js\",\n    \"browsers\": [\n      \"ie/9..latest\",\n      \"firefox/19..latest\",\n      \"chrome/25..latest\",\n      \"safari/latest\",\n      \"iphone/6\",\n      \"ipad/6\"\n    ]\n  }\n}\n"},"957a56ec96fd8c8f14d524bd63f09811575d8713":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure node js\",\n  \"version\": \"0.1.1\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"engines\": {\n    \"node\": \">=0.6.0\"\n  },\n  \"scripts\": {\n    \"test\": \"node test.js\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"optionalDependencies\": {}\n}\n"},"f8a10a88fc083f43083d0393062dfeddb9b32ae6":{"type":"blob","body":"# msgpack for node\n\n[![Build Status](https://secure.travis-ci.org/creationix/msgpack-js.png)](http://travis-ci.org/creationix/msgpack-js)\n\nA handwritten msgpack encoder and decoder for Node.JS and modern browsers.\n\nThe original format can be found at <http://wiki.msgpack.org/display/MSGPACK/Format+specification>\n\n\n## Extension\n\nI've extended the format a little to allow for encoding and decoding of `undefined` and `Buffer` instances.\n\nThis required three new type codes that were previously marked as \"reserved\".\nThis change means that using these new types will render your serialized data\nincompatible with other messagepack implementations that don't have the same\nextension.\n\nThere are two new types for storing node `Buffer` instances. These work just \nlike \"raw 16\" and \"raw 32\" except they are node buffers instead of strings.\n\n    buffer 16  11011000  0xd8\n    buffer 32  11011001  0xd9\n\nAlso I've added a type for `undefined` that works just like the `null` type.\n\n    undefined  11000100  0xc4\n\n## Usage\n\n``` javascript\nvar msgpack = require('msgpack');\nvar assert = require('assert');\n\nvar initial = {Hello: \"World\"};\nvar encoded = msgpack.encode(initial);\nvar decoded = msgpack.decode(encoded);\n\nassert.deepEqual(initial, decoded);\n```\n\n"},"ed8ce267449a2e4a290db802af8d6ab6ea0ec545":{"type":"blob","body":"/*global Buffer*/\n\nvar assert = require('assert'),\n    msgpack = require('./msgpack');\n\nvar tests = [\n  true, false, null,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world',\n  [1,2,3], [], {name: \"Tim\", age: 28}, {},\n  // {\"a\" : 1, \"b\" : 2, \"c\" : [1, 2, 3]},\n];\n[0x100, 0x1000, 0x10000, 0x100000].forEach(function (length) {\n  var list = new Array(length), obj = {};\n  for (var i = 0; i < length; i++) {\n    list[i] = i;\n    obj[i] = i;\n  }\n  tests.push(list);\n  tests.push(obj);\n});\n\ntests.forEach(function (o) {\n  process.stdout.write(\"Testing \" + JSON.stringify(o).substr(0, 10));\n  var b = msgpack.pack(o);\n  process.stdout.write(' \\t.');\n  var oo = msgpack.unpack(b, 'utf8');\n  process.stdout.write('o');\n  try {\n    assert.deepEqual(oo, o);\n    process.stdout.write('O\\n');\n  } catch (err) {\n    process.stdout.write('X\\n');\n    console.dir([o, b, oo]);\n  }\n});\n"},"08ddffdb3f3452488363db3803d8271eec7c8434":{"type":"blob","body":"var msgpack = require('./msgpack');\nvar util = require('util');\nvar assert = require('assert');\n\nvar tests = [\n  true, false, null, undefined,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world', Buffer(\"Hello\"), Buffer(\"World\"),\n  [1,2,3], [], {name: \"Tim\", age: 29}, {},\n  {a: 1, b: 2, c: [1, 2, 3]},\n];\nfor (var i = 0, l = tests.length; i < l; i++) {\n  var test = tests[i];\n  if (typeof test === 'number') {\n    tests.push(test + 1);\n    tests.push(test + 1);\n    tests.push(test + 0.5);\n  }\n}\n[0x100, 0x1000, 0x10000, 0x100000].forEach(function (length) {\n  var list = new Array(length), obj = {};\n  for (var i = 0; i < length; i++) {\n    list[i] = i;\n    obj[i] = i;\n  }\n  tests.push(list);\n  tests.push(obj);\n});\n\nvar width = process.stdout.getWindowSize()[0];\nvar mistakes = 0;\ntests.forEach(function (test) {\n  var encoded = msgpack.encode(test);\n  console.log(encoded.inspect().substr(0, width));\n  var decoded = msgpack.decode(encoded);\n  try {\n    assert.deepEqual(test, decoded);\n    if (typeof test === \"object\" && test !== null) {\n      assert.equal(test.constructor, decoded.constructor);\n    }\n  } catch (err) {\n    console.log();\n    console.log(util.inspect(test).replace(/\\n */g, '').substr(0, width));\n    console.log(util.inspect(decoded).replace(/\\n */g, '').substr(0, width));\n    console.log(err.stack);\n    mistakes++;\n  }\n});\nprocess.exit(mistakes);\n"},"92e70e6cbcb1db23d1dfca660cc4b9962e6d9ba2":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"bae85dcb004c3b1023e0d5da461ddfd861246567"},{"mode":33188,"name":"msgpack.js","hash":"9108faf6b226321507525a699856b5d5ae427284"},{"mode":33188,"name":"package.json","hash":"6c773b78f234659fdbe336336d242401b91aad6f"},{"mode":33188,"name":"test.js","hash":"eb579ea870af3232f018b87d601dad9d1dbf70bf"}]},"b88a60a16b93962f9b1f9cb89d435ea40df67dc1":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"bae85dcb004c3b1023e0d5da461ddfd861246567"},{"mode":33188,"name":"msgpack.js","hash":"bb2bb759c65d460689172b2abf74cef257848786"},{"mode":33188,"name":"package.json","hash":"a810c850b6f5b457244fce6a8651ff69c1cc61a6"},{"mode":33188,"name":"test.js","hash":"eb579ea870af3232f018b87d601dad9d1dbf70bf"}]},"fc6d8a556524b1dd9bd69c462951bb95c068b9ba":{"type":"tree","body":[{"mode":33188,"name":"README.markdown","hash":"bae85dcb004c3b1023e0d5da461ddfd861246567"},{"mode":33188,"name":"msgpack.js","hash":"9108faf6b226321507525a699856b5d5ae427284"},{"mode":33188,"name":"package.json","hash":"ea0ab5cd2e170e0fc131f90ff08045b3c4183b1a"},{"mode":33188,"name":"test.js","hash":"eb579ea870af3232f018b87d601dad9d1dbf70bf"}]},"95e1e0c5c4c16cce6589d4dc6d31de7c3ee112fc":{"type":"blob","body":"/*global Buffer*/\n\nfunction Packer(push) {\n  this.push = push;\n}\nPacker.prototype = {\n  constructor: Packer,\n  INT8: function (num) {\n    this.push((num >>> 0) & 0xff);\n  },\n  INT16: function (num) {\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT32: function (num) {\n    this.push((num >>> 24) & 0xff);\n    this.push((num >>> 16) & 0xff);\n    this.push((num >>> 8) & 0xff);\n    this.push((num >>> 0) & 0xff);\n  },\n  INT64: function (num) {\n    // TODO: Implement this, it's tricky\n    // Needs to accept unsigned up to 64 bits\n    // and signed up to 63 bits + sign bit\n    throw new Error(\"INT64 not implemented!\");\n  },\n  SINGLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 single precision floating point number \n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    throw new Error(\"SINGLE not implemented!\");\n  },\n  DOUBLE: function (num) {\n    // TODO: Implement\n    // big-endian IEEE 754 double precision floating point number\n    // XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX_XXXXXXXX\n    throw new Error(\"DOUBLE not implemented!\");\n  },\n  integer: function (num) {\n    if (num >= 0) {\n      // positive fixnum\n      if (num < 0x80) {\n        this.INT8(num);\n        return;\n      }\n      // uint 8\n      if (num < 0x100) {\n        this.push(0xcc);\n        this.INT8(num);\n        return;\n      }\n      // uint 16\n      if (num < 0x10000) {\n        this.push(0xcd);\n        this.INT16(num);\n        return;\n      }\n      // uint 32\n      if (num < 0x100000000) {\n        this.push(0xce);\n        this.INT32(num);\n        return;\n      }\n      // uint 64\n      if (num < 0x10000000000000000) {\n        this.push(0xcf);\n        this.INT64(num);\n        return;\n      }\n      throw new Error(\"Number to large\");\n    }\n    // negative fixnum\n    if (num >= 20) {\n      this.INT8(num);\n      return;\n    }\n    // int 8\n    if (num >= -0x80) {\n      this.push(0xd0);\n      this.INT8(num);\n      return;\n    }\n    // int 16\n    if (num >= -0x8000) {\n      this.push(0xd1);\n      this.INT16(num);\n      return;\n    }\n    // int 32\n    if (num >= -0x80000000) {\n      this.push(0xd2);\n      this.INT32(num);\n      return;\n    }\n    // int 64\n    if (num >= -0x8000000000000000) {\n      this.push(0xd3);\n      this.INT64(num);\n      return;\n    }\n    throw new Error(\"Number to small\");\n  },\n  float: function (num) {\n    // TODO: Detect when SINGLE is enough precision somehow\n    this.push(0xcb);\n    this.DOUBLE(num);\n  },\n  raw: function (buffer) {\n    // fix raw\n    if (buffer.length < 0x20) {\n      this.push(0xa0 || buffer.length);\n      this.push(buffer);\n      return;\n    }\n    // raw 16\n    if (buffer.length < 0x10000) {\n      this.push(0xda);\n      this.push(buffer);\n      return;\n    }\n    // raw 32\n    if (buffer.length < 0x100000000) {\n      this.push(0xdb);\n      this.push(buffer);\n      return;\n    }\n    throw new Error(\"Raw buffer too long\");\n  },\n  array: function (val) {\n    if (val.length < 0x10) {\n      // fix array\n      this.push(0x90 | val.length);\n    } else if (val.length < 0x10000) {\n      // array 16\n      this.push(0xdc);\n      this.INT16(val.length);\n    } else if (val.length < 0x100000000) {\n      // array 32\n      this.push(0xdd);\n      this.INT32(val.length);\n    } else {\n      throw new Error(\"Array too long\");\n    }\n    val.forEach(function (item) {\n      this.pack(item);\n    }, this);\n  },\n  map: function (val) {\n    var keys = Object.keys(val);\n    if (keys.length < 0x10) {\n      // fix map\n      this.push(0x80 | keys.length);\n    } else if (keys.length < 0x10000) {\n      // map 16\n      this.push(0xde);\n      this.INT16(keys.length);\n    } else if (keys.length < 0x100000000) {\n      // map 32\n      this.push(0xdf);\n      this.INT32(keys.length);\n    } else {\n      throw new Error(\"Map too long\");\n    }\n    keys.forEach(function (key) {\n      this.pack(key);\n      this.pack(val[key]);\n    }, this);\n  },\n  pack: function (val) {\n    // nil\n    if (val === null || val === undefined) {\n      this.push(0xc0);\n      return;\n    }\n    // true\n    if (val === true) {\n      this.push(0xc3);\n      return;\n    }\n    // false\n    if (val === false) {\n      this.push(0xc2);\n      return;\n    }\n    if (typeof val === 'number') {\n      if (Math.floor(val) === val) {\n        this.integer(val);\n        return;\n      }\n      this.float(val);\n      return;\n    }\n    if (typeof val === 'string') {\n      // Encode strings as buffers\n      this.raw(new Buffer(val));\n    }\n    if (typeof val === 'object') {\n      if (val instanceof Buffer) {\n        this.raw(val);\n        return;\n      }\n      if (Array.isArray(val)) {\n        this.array(val);\n        return;\n      }\n      this.map(val);\n      return;\n    }\n    console.dir(val);\n    throw new Error(\"Unknown value\");\n  }\n};\n\nfunction Parser(emit) {\n  this.emit = emit;\n  this.left = 0;\n  this.buffer = [];\n  this.consume = function () {};\n}\nParser.prototype = {\n  constructor: Parser,\n  push: function (byte) {\n    // Accept buffers as batch bytes\n    if (byte instanceof Buffer) {\n      for (var i = 0, l = byte.length; i < l; i++) {\n        this.push(byte[i]);\n      }\n      return;\n    }\n    // Hook to consume message bodies\n    if (this.left > 0) {\n      this.buffer.push(byte);\n      this.left--;\n      if (this.left === 0) {\n        this.consume();\n      }\n      return;\n    }\n    if (byte >= 0x00 && byte < 0x80) {\n      // fixnum\n      emit(byte);\n      return;\n    }\n    if (byte >= 0xe0 && byte < 0x100) {\n      // negative fixnum\n      emit(byte - 0xf0);\n      return;\n    }\n    if (byte >= 0xc0 && byte < 0xe0) {\n      // variable\n      return;\n    }\n    if (byte === 0xc0) {\n      // nil\n      this.emit(null);\n      return;\n    }\n    if (byte === 0xdc) {\n      // array 16\n      this.left = 2;\n      this.consume = this.array;\n    }\n    throw new Error(\"Unknown sequence encountered\");\n  }\n};\n\nfunction encode(val) {\n  var bytes = [];\n  function accum(byte) {\n    bytes.push(byte);\n  }\n  var packer = new Packer(accum);\n  console.dir(packer);\n  console.dir(packer.__proto__);\n  packer.pack(val);\n  return bytes;\n}\n\nfunction dump(num) {\n  var line = \"00000000\" + num.toString(2);\n  line = line.substr(line.length - 8);\n  process.stdout.write(line + \" \");\n}\n\nvar nums = [];\nfor (var i = 1; i < 0x100000000; i *= 2) {\n  for (var n = 0; n < 4; n++) {\n    var num = (Math.random() > 0.5) ?\n      Math.floor(Math.random() * i) :\n      Math.floor(-Math.random() * i / 2);\n    nums[num] = true;  \n  }\n}\nnums = Object.keys(nums).map(function (num) {\n  return parseInt(num, 10);\n});\nvar json = new Buffer(JSON.stringify(nums));\nvar msgpack = new Buffer(encode(nums));\n\nconsole.dir(json);\nconsole.dir(msgpack);\nconsole.log(\"%s numbers in an array\", nums.length);\nconsole.log(\"%s vs %s\", json.length, msgpack.length);\n"},"8c49dcc4d3f942cf9e9ed48b70520b836bcc9075":{"type":"blob","body":"var msgpack = require('./msgpack');\nvar util = require('util');\nvar assert = require('assert');\n\nvar tests = [\n  true, false, null, undefined,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000,\n  0x20000, -0x20000, 0x40000,-0x40000,\n  10, 100, 1000, 10000, 100000, 1000000,\n  -10, -100, -1000, -10000, -100000, -1000000,\n  'hello', 'world', Buffer(\"Hello\"), Buffer(\"World\"),\n  [1,2,3], [], {name: \"Tim\", age: 29}, {},\n  {a: 1, b: 2, c: [1, 2, 3]},\n];\n[0x100, 0x1000, 0x10000, 0x100000].forEach(function (length) {\n  var list = new Array(length), obj = {};\n  for (var i = 0; i < length; i++) {\n    list[i] = i;\n    obj[i] = i;\n  }\n  tests.push(list);\n  tests.push(obj);\n});\n\nvar width = process.stdout.getWindowSize()[0];\nvar mistakes = 0;\ntests.forEach(function (test) {\n  var encoded = msgpack.encode(test);\n  console.log(encoded.inspect().substr(0, width));\n  var decoded = msgpack.decode(encoded);\n  try {\n    assert.deepEqual(test, decoded);\n    if (typeof test === \"object\" && test !== null) {\n      assert.equal(test.constructor, decoded.constructor);\n    }\n  } catch (err) {\n    console.log();\n    console.log(util.inspect(test).replace(/\\n */g, '').substr(0, width));\n    console.log(util.inspect(decoded).replace(/\\n */g, '').substr(0, width));\n    console.log(err.stack);\n    mistakes++;\n  }\n});\nprocess.exit(mistakes);\n"},"fcc051343e889487e9c5a8128c56645c079d1798":{"type":"blob","body":"/*global Buffer*/\n\nvar assert = require('assert'),\n    msgpack = require('./msgpack');\n\nvar tests = [\n  true, false, null,\n  0, 1, -1, 2, -2, 4, -4, 6, -6,\n  0x10, -0x10, 0x20, -0x20, 0x40, -0x40,\n  0x80, -0x80, 0x100, -0x100, 0x200, -0x100,\n  0x1000, -0x1000, 0x10000, -0x10000\n  // {\"a\" : 1, \"b\" : 2, \"c\" : [1, 2, 3]},\n];\n\ntests.forEach(function (o) {\n  process.stdout.write(\"Testing \" + JSON.stringify(o));\n  var b = msgpack.pack(o);\n  process.stdout.write(' \\t.');\n  var oo = msgpack.unpack(b);\n  process.stdout.write('o');\n  try {\n    assert.deepEqual(oo, o);\n    process.stdout.write('O\\n');\n  } catch (err) {\n    process.stdout.write('X\\n');\n    console.dir([o, b, oo]);\n  }\n});\n"},"6d4ee24c360c599a71ab14e9f12c458ccce1e646":{"type":"blob","body":"# msgpack for node\n\nA handwritten msgpack encoder and decoder for Node.JS.\n\nThe original format can be found at <http://wiki.msgpack.org/display/MSGPACK/Format+specification>\n\n\n## Extension\n\nI've extended the format a little to allow for encoding and decoding of `undefined` and `Buffer` instances.\n\nThis required three new type codes that were previously marked as \"reserved\".\nThis change means that using these new types will render your serialized data\nincompatible with other messagepack implementations that don't have the same\nextension.\n\nThere are two new types for storing node `Buffer` instances. These work just \nlike \"raw 16\" and \"raw 32\" except they are node buffers instead of strings.\n\n    buffer 16  11011000  0xd8\n    buffer 32  11011001  0xd9\n\nAlso I've added a type for `undefined` that works just like the `null` type.\n\n    undefined  11000100  0xc4\n\n## Usage\n\n    var msgpack = require('msgpack');\n    var assert = require('assert');\n\n    var initial = {Hello: \"World\"};\n    var encoded = msgpack.encode(initial);\n    var decoded = msgpack.decode(encoded);\n\n    assert.deepEqual(initial, decoded);\n\n"},"bae85dcb004c3b1023e0d5da461ddfd861246567":{"type":"blob","body":"# msgpack for node\n\nA handwritten msgpack encoder and decoder for Node.JS.\n\nThe original format can be found at <http://wiki.msgpack.org/display/MSGPACK/Format+specification>\n\n\n## Extension\n\nI've extended the format a little to allow for encoding and decoding of `undefined` and `Buffer` instances.\n\nThis required three new type codes that were previously marked as \"reserved\".\nThis change means that using these new types will render your serialized data\nincompatible with other messagepack implementations that don't have the same\nextension.\n\nThere are two new types for storing node `Buffer` instances. These work just \nlike \"raw 16\" and \"raw 32\" except they are node buffers instead of strings.\n\n    buffer 16  11011000  0xd8\n    buffer 32  11011001  0xd9\n\nAlso I've added a type for `undefined` that works just like the `null` type.\n\n    undefined  11000100  0xc4\n\n## Usage\n\n``` javascript\nvar msgpack = require('msgpack');\nvar assert = require('assert');\n\nvar initial = {Hello: \"World\"};\nvar encoded = msgpack.encode(initial);\nvar decoded = msgpack.decode(encoded);\n\nassert.deepEqual(initial, decoded);\n```\n\n"},"e8757048063dc4c3d6af4401220ac23581f2c60c":{"type":"blob","body":"# msgpack for node\n\n[![Build Status](https://secure.travis-ci.org/creationix/msgpack-js.png)](http://travis-ci.org/creationix/msgpack-js)\n\nA handwritten msgpack encoder and decoder for Node.JS.\n\nThe original format can be found at <http://wiki.msgpack.org/display/MSGPACK/Format+specification>\n\n\n## Extension\n\nI've extended the format a little to allow for encoding and decoding of `undefined` and `Buffer` instances.\n\nThis required three new type codes that were previously marked as \"reserved\".\nThis change means that using these new types will render your serialized data\nincompatible with other messagepack implementations that don't have the same\nextension.\n\nThere are two new types for storing node `Buffer` instances. These work just \nlike \"raw 16\" and \"raw 32\" except they are node buffers instead of strings.\n\n    buffer 16  11011000  0xd8\n    buffer 32  11011001  0xd9\n\nAlso I've added a type for `undefined` that works just like the `null` type.\n\n    undefined  11000100  0xc4\n\n## Usage\n\n``` javascript\nvar msgpack = require('msgpack');\nvar assert = require('assert');\n\nvar initial = {Hello: \"World\"};\nvar encoded = msgpack.encode(initial);\nvar decoded = msgpack.decode(encoded);\n\nassert.deepEqual(initial, decoded);\n```\n\n"},"ea0ab5cd2e170e0fc131f90ff08045b3c4183b1a":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure node js\",\n  \"version\": \"0.1.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"engines\": {\n    \"node\": \"~0.6.0\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"optionalDependencies\": {}\n}\n"},"6c773b78f234659fdbe336336d242401b91aad6f":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure node js\",\n  \"version\": \"0.1.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"engines\": {\n    \"node\": \">=0.6.0\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"optionalDependencies\": {}\n}\n"},"a810c850b6f5b457244fce6a8651ff69c1cc61a6":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure node js\",\n  \"version\": \"0.1.1\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"engines\": {\n    \"node\": \">=0.6.0\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"optionalDependencies\": {}\n}\n"},"85de88d3b7ea78dc2e81f7a182d947ab5cb83ca6":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure node js\",\n  \"version\": \"0.1.1\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"engines\": {\n    \"node\": \">=0.6.0\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"optionalDependencies\": {}\n}"},"7b83f33631db2ef0ca9603d678cbda23c4144cb9":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure node js\",\n  \"version\": \"0.1.5\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"engines\": {\n    \"node\": \">=0.6.0\"\n  },\n  \"dependencies\": {},\n  \"devDependencies\": {},\n  \"optionalDependencies\": {}\n}\n"},"2346e9edaccfc7dd2fa30c970d8d4346a6780ac7":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure javascript\",\n  \"version\": \"0.2.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"dependencies\": {\n    \"bops\": \"~0.0.5\"\n  },\n}\n"},"9108faf6b226321507525a699856b5d5ae427284":{"type":"blob","body":"exports.encode = function (value) {\n  var buffer = new Buffer(sizeof(value));\n  encode(value, buffer, 0);\n  return buffer;\n}\n\nexports.decode = decode;\n\n// http://wiki.msgpack.org/display/MSGPACK/Format+specification\n// I've extended the protocol to have two new types that were previously reserved.\n//   buffer 16  11011000  0xd8\n//   buffer 32  11011001  0xd9\n// These work just like raw16 and raw32 except they are node buffers instead of strings.\n//\n// Also I've added a type for `undefined`\n//   undefined  11000100  0xc4\n\nfunction decode(buffer, offset) {\n  var offset = 0;\n  function map(length) {\n    var value = {};\n    for (var i = 0; i < length; i++) {\n      var key = parse();\n      value[key] = parse();\n    }\n    return value;\n  }\n  function buf(length) {\n    var value = buffer.slice(offset, offset + length);\n    offset += length;\n    return value;\n  }\n  function raw(length) {\n    var value = buffer.toString('utf8', offset, offset + length);\n    offset += length;\n    return value;\n  }\n  function array(length) {\n    var value = new Array(length);\n    for (var i = 0; i < length; i++) {\n      value[i] = parse();\n    }\n    return value;\n  }\n  function parse() {\n    var type = buffer[offset];\n    var value, length;\n    switch (type) {\n    // nil\n    case 0xc0:\n      offset++;\n      return null;\n    // false\n    case 0xc2:\n      offset++;\n      return false;\n    // true\n    case 0xc3:\n      offset++;\n      return true;\n    // undefined\n    case 0xc4:\n      offset++;\n      return undefined;\n    // float      \n    case 0xca:\n      value = buffer.readFloatBE(offset + 1);\n      offset += 5;\n      return value;\n    // double\n    case 0xcb:\n      value = buffer.readDoubleBE(offset + 1);\n      offset += 9;\n      return value;\n    // uint8\n    case 0xcc:\n      value = buffer[offset + 1];\n      offset += 2;\n      return value;\n    // uint 16\n    case 0xcd:\n      value = buffer.readUInt16BE(offset + 1);\n      offset += 3;\n      return value;\n    // uint 32\n    case 0xce:\n      value = buffer.readUInt32BE(offset + 1);\n      offset += 5;\n      return value;\n    // uint64\n    case 0xcf:\n      value = buffer.readUInt64BE(offset + 1);\n      offset += 9;\n      return value;\n    // int 8\n    case 0xd0:\n      value = buffer.readInt8(offset + 1);\n      offset += 2;\n      return value;\n    // int 16\n    case 0xd1:\n      value = buffer.readInt16BE(offset + 1);\n      offset += 3;\n      return value;\n    // int 32\n    case 0xd2:\n      value = buffer.readInt32BE(offset + 1);\n      offset += 5;\n      return value;\n    // int 64\n    case 0xd3:\n      value = buffer.readInt64BE(offset + 1);\n      offset += 9;\n      return value;\n    // map 16\n    case 0xde:\n      length = buffer.readUInt16BE(offset + 1);\n      offset += 3;\n      return map(length);\n    // map 32\n    case 0xdf:\n      length = buffer.readUInt32BE(offset + 1);\n      offset += 5;\n      return map(length);\n    // array 16\n    case 0xdc:\n      length = buffer.readUInt16BE(offset + 1);\n      offset += 3;\n      return array(length);\n    // array 32\n    case 0xdd:\n      length = buffer.readUInt32BE(offset + 1);\n      offset += 5;\n      return array(length);\n    // buffer 16\n    case 0xd8:\n      length = buffer.readUInt16BE(offset + 1);\n      offset += 3;\n      return buf(length);\n    // buffer 32\n    case 0xd9:\n      length = buffer.readUInt32BE(offset + 1);\n      offset += 5;\n      return buf(length);\n    // raw 16\n    case 0xda:\n      length = buffer.readUInt16BE(offset + 1);\n      offset += 3;\n      return raw(length);\n    // raw 32\n    case 0xdb:\n      length = buffer.readUInt32BE(offset + 1);\n      offset += 5;\n      return raw(length);\n    }\n    // FixRaw\n    if ((type & 0xe0) === 0xa0) {\n      length = type & 0x1f;\n      offset++;\n      return raw(length);\n    }\n    // FixMap\n    if ((type & 0xf0) === 0x80) {\n      length = type & 0x0f;\n      offset++;\n      return map(length);\n    }\n    // FixArray\n    if ((type & 0xf0) === 0x90) {\n      length = type & 0x0f;\n      offset++;\n      return array(length);\n    }\n    // Positive FixNum\n    if ((type & 0x80) === 0x00) {\n      offset++;\n      return type;\n    }\n    // Negative Fixnum\n    if ((type & 0xe0) === 0xe0) {\n      value = buffer.readInt8(offset);\n      offset++;\n      return value;\n    }\n    throw new Error(\"Unknown type 0x\" + type.toString(16));\n  }\n  var value = parse();\n  if (offset !== buffer.length) throw new Error((buffer.length - offset) + \" trailing bytes\");\n  return value;\n}\n\nfunction encode(value, buffer, offset) {\n  var type = typeof value;\n\n  // Strings Bytes\n  if (type === \"string\") {\n    var length = Buffer.byteLength(value);\n    // fix raw\n    if (length < 0x20) {\n      buffer[offset] = length | 0xa0;\n      buffer.write(value, offset + 1);\n      return 1 + length;\n    }\n    // raw 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xda;\n      buffer.writeUInt16BE(length, offset + 1);\n      buffer.write(value, offset + 3);\n      return 3 + length;\n    }\n    // raw 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xdb;\n      buffer.writeUInt32BE(length, offset + 1);\n      buffer.write(value, offset + 5);\n      return 5 + length;\n    }\n  }\n\n  if (Buffer.isBuffer(value)) {\n    var length = value.length;\n    // buffer 16\n    if (length < 0x10000) {\n      buffer[offset] = 0xd8;\n      buffer.writeUInt16BE(length, offset + 1);\n      value.copy(buffer, offset + 3);\n      return 3 + length;\n    }\n    // buffer 32\n    if (length < 0x100000000) {\n      buffer[offset] = 0xd9;\n      buffer.writeUInt32BE(length, offset + 1);\n      value.copy(buffer, offset + 5);\n      return 5 + length;\n    }\n  }\n  \n  if (type === \"number\") {\n    // Floating Point\n    if ((value << 0) !== value) {\n      buffer[offset] =  0xcb;\n      buffer.writeDoubleBE(value, offset + 1);\n      return 9;\n    }\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) {\n        buffer[offset] = value;\n        return 1;\n      }\n      // uint 8\n      if (value < 0x100) {\n        buffer[offset] = 0xcc;\n        buffer[offset + 1] = value;\n        return 2;\n      }\n      // uint 16\n      if (value < 0x10000) {\n        buffer[offset] = 0xcd;\n        buffer.writeUInt16BE(value, offset + 1);\n        return 3;\n      }\n      // uint 32\n      if (value < 0x100000000) {\n        buffer[offset] = 0xce;\n        buffer.writeUInt32BE(value, offset + 1);\n        return 5;\n      }\n      // uint 64\n      if (value < 0x10000000000000000) {\n        buffer[offset] = 0xcf;\n        buffer.writeUInt64BE(value, offset + 1);\n        return 9;\n      }\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) {\n      buffer.writeInt8(value, offset);\n      return 1;\n    }\n    // int 8\n    if (value >= -0x80) {\n      buffer[offset] = 0xd0;\n      buffer.writeInt8(value, offset + 1);\n      return 2;\n    }\n    // int 16\n    if (value >= -0x8000) {\n      buffer[offset] = 0xd1;\n      buffer.writeInt16BE(value, offset + 1);\n      return 3;\n    }\n    // int 32\n    if (value >= -0x80000000) {\n      buffer[offset] = 0xd2;\n      buffer.writeInt32BE(value, offset + 1);\n      return 5;\n    }\n    // int 64\n    if (value >= -0x8000000000000000) {\n      buffer[offset] = 0xd3;\n      buffer.writeInt64BE(value, offset + 1);\n      return 9;\n    }\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  \n  // undefined\n  if (type === \"undefined\") {\n    buffer[offset] = 0xc4;\n    return 1;\n  }\n  \n  // null\n  if (value === null) {\n    buffer[offset] = 0xc0;\n    return 1;\n  }\n\n  // Boolean\n  if (type === \"boolean\") {\n    buffer[offset] = value ? 0xc3 : 0xc2;\n    return 1;\n  }\n  \n  // Container Types\n  if (type === \"object\") {\n    var length, size = 0;\n    var isArray = Array.isArray(value);\n\n    if (isArray) {\n      length = value.length;\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n    }\n\n    var size;\n    if (length < 0x10) {\n      buffer[offset] = length | (isArray ? 0x90 : 0x80);\n      size = 1;\n    }\n    else if (length < 0x10000) {\n      buffer[offset] = isArray ? 0xdc : 0xde;\n      buffer.writeUInt16BE(length, offset + 1);\n      size = 3;\n    }\n    else if (length < 0x100000000) {\n      buffer[offset] = isArray ? 0xdd : 0xdf;\n      buffer.writeUInt32BE(length, offset + 1);\n      size = 5;\n    }\n\n    if (isArray) {\n      for (var i = 0; i < length; i++) {\n        size += encode(value[i], buffer, offset + size);\n      }\n    }\n    else {\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += encode(key, buffer, offset + size);\n        size += encode(value[key], buffer, offset + size);\n      }\n    }\n    \n    return size;\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\nfunction sizeof(value) {\n  var type = typeof value;\n\n  // Raw Bytes\n  if (type === \"string\") {\n    var length = Buffer.byteLength(value);\n    if (length < 0x20) {\n      return 1 + length;\n    }\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n  \n  if (Buffer.isBuffer(value)) {\n    var length = value.length;\n    if (length < 0x10000) {\n      return 3 + length;\n    }\n    if (length < 0x100000000) {\n      return 5 + length;\n    }\n  }\n  \n  if (type === \"number\") {\n    // Floating Point\n    // double\n    if (value << 0 !== value) return 9;\n\n    // Integers\n    if (value >=0) {\n      // positive fixnum\n      if (value < 0x80) return 1;\n      // uint 8\n      if (value < 0x100) return 2;\n      // uint 16\n      if (value < 0x10000) return 3;\n      // uint 32\n      if (value < 0x100000000) return 5;\n      // uint 64\n      if (value < 0x10000000000000000) return 9;\n      throw new Error(\"Number too big 0x\" + value.toString(16));\n    }\n    // negative fixnum\n    if (value >= -0x20) return 1;\n    // int 8\n    if (value >= -0x80) return 2;\n    // int 16\n    if (value >= -0x8000) return 3;\n    // int 32\n    if (value >= -0x80000000) return 5;\n    // int 64\n    if (value >= -0x8000000000000000) return 9;\n    throw new Error(\"Number too small -0x\" + value.toString(16).substr(1));\n  }\n  \n  // Boolean, null, undefined\n  if (type === \"boolean\" || type === \"undefined\" || value === null) return 1;\n  \n  // Container Types\n  if (type === \"object\") {\n    var length, size = 0;\n    if (Array.isArray(value)) {\n      length = value.length;\n      for (var i = 0; i < length; i++) {\n        size += sizeof(value[i]);\n      }\n    }\n    else {\n      var keys = Object.keys(value);\n      length = keys.length;\n      for (var i = 0; i < length; i++) {\n        var key = keys[i];\n        size += sizeof(key) + sizeof(value[key]);\n      }\n    }\n    if (length < 0x10) {\n      return 1 + size;\n    }\n    if (length < 0x10000) {\n      return 3 + size;\n    }\n    if (length < 0x100000000) {\n      return 5 + size;\n    }\n    throw new Error(\"Array or object too long 0x\" + length.toString(16));\n  }\n  throw new Error(\"Unknown type \" + type);\n}\n\n\n"},"6c3391a11573e754ace624ac719df7af81b5ec27":{"type":"blob","body":"{\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"name\": \"msgpack-js\",\n  \"description\": \"msgpack encoder and decoder in pure javascript\",\n  \"version\": \"0.2.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/msgpack-js.git\"\n  },\n  \"main\": \"msgpack.js\",\n  \"dependencies\": {\n    \"bops\": \"~0.0.5\"\n  }\n}\n"},"33118490d518b8b3edbf926d1e35e4e5a3dd805e":{"type":"blob","body":"# msgpack for node\n\nA handwritten msgpack encoder and decoder for Node.JS.\n\nI've extended the format a little to allow for encoding and decoding of `undefined` and `Buffer` instances.\n\n## Usage\n\n    var msgpack = require('msgpack');\n    var assert = require('assert');\n\n    var initial = {Hello: \"World\"};\n    var encoded = msgpack.encode(initial);\n    var decoded = msgpack.decode(encoded);\n\n    assert.deepEqual(initial, decoded);\n\n"}}}