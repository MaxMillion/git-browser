{"refs":{"refs/heads/master":"cc172c90b64c019eebd0ff18fd6ea26ce5ce2387","refs/pull/2/head":"1a4da01a75fd0f2d80af1c0585bccfa54ca20d20","refs/pull/2/merge":"5d1ce81dcb3a412221f034c55c152055cfc12ff5","refs/pull/3/head":"b151ce453ad03e1cbbaa37240573b40ae39bb2b8","refs/pull/3/merge":"c607352347c38fb43c34613a3220e24667fb5a14","refs/pull/4/head":"06165d064052eb3cf4cd91facc8ef7f16d1859ad","refs/pull/4/merge":"4c2be27f2f6e5bee6957eeaeb5e138b9030596aa","refs/pull/6/head":"337059bf6d3e10a966eff97769dd77a441a29f32","refs/pull/6/merge":"e0e38121b3d39232adc6103b307fddba65aed597","refs/pull/7/head":"52b86fd0b153168f63919426572e14b051039141","refs/pull/7/merge":"13bd5f2a74efea36200c796340c3fc31923282c0","refs/pull/8/head":"0eeee5f894face8b84d6f8ee70710cf0e68546e7","refs/pull/8/merge":"8892a3ca6dba723368bca4fc35aa915aa9906b24","refs/tags/0.1.0":"6def309873599c8c803c842f64aba6b2f44a2d6c"},"objects":{"13bd5f2a74efea36200c796340c3fc31923282c0":{"type":"commit","body":{"tree":"8e6a1db11e855f48ec5204e8a78795f322f02904","parents":["cc172c90b64c019eebd0ff18fd6ea26ce5ce2387","52b86fd0b153168f63919426572e14b051039141"],"author":"Tomi Belan <tomi.belan@gmail.com> 1377962319 -0700","committer":"Tomi Belan <tomi.belan@gmail.com> 1377962319 -0700","message":"Merge 52b86fd0b153168f63919426572e14b051039141 into cc172c90b64c019eebd0ff18fd6ea26ce5ce2387\n"}},"cc172c90b64c019eebd0ff18fd6ea26ce5ce2387":{"type":"commit","body":{"tree":"69eaefd51eb7a12beea12c9c51d80df683713168","parents":["249a0212295d6f0e463fbf62bb87e885dbba62e5","337059bf6d3e10a966eff97769dd77a441a29f32"],"author":"Tim Caswell <tim@creationix.com> 1377956151 -0700","committer":"Tim Caswell <tim@creationix.com> 1377956151 -0700","message":"Merge pull request #6 from TomiBelan/fix5\n\nFix throwing errors into the generator"}},"8892a3ca6dba723368bca4fc35aa915aa9906b24":{"type":"commit","body":{"tree":"d611852a71841ef6aefcc0c4e07bb5f71a4703a5","parents":["249a0212295d6f0e463fbf62bb87e885dbba62e5","0eeee5f894face8b84d6f8ee70710cf0e68546e7"],"author":"Tomi Belan <tomi.belan@gmail.com> 1377938650 -0700","committer":"Tomi Belan <tomi.belan@gmail.com> 1377938650 -0700","message":"Merge 0eeee5f894face8b84d6f8ee70710cf0e68546e7 into 249a0212295d6f0e463fbf62bb87e885dbba62e5\n"}},"52b86fd0b153168f63919426572e14b051039141":{"type":"commit","body":{"tree":"8e6a1db11e855f48ec5204e8a78795f322f02904","parents":["337059bf6d3e10a966eff97769dd77a441a29f32"],"author":"Tomi Belan <tomi.belan@gmail.com> 1377390841 -0700","committer":"Tomi Belan <tomi.belan@gmail.com> 1377402664 -0700","message":"Always use an implicit done callback.\n"}},"0eeee5f894face8b84d6f8ee70710cf0e68546e7":{"type":"commit","body":{"tree":"d611852a71841ef6aefcc0c4e07bb5f71a4703a5","parents":["52b86fd0b153168f63919426572e14b051039141"],"author":"Tomi Belan <tomi.belan@gmail.com> 1377402350 -0700","committer":"Tomi Belan <tomi.belan@gmail.com> 1377402664 -0700","message":"Make gen more strict about being called exactly once\n"}},"e0e38121b3d39232adc6103b307fddba65aed597":{"type":"commit","body":{"tree":"69eaefd51eb7a12beea12c9c51d80df683713168","parents":["249a0212295d6f0e463fbf62bb87e885dbba62e5","337059bf6d3e10a966eff97769dd77a441a29f32"],"author":"Tomi Belan <tomi.belan@gmail.com> 1377398477 -0700","committer":"Tomi Belan <tomi.belan@gmail.com> 1377398477 -0700","message":"Merge 337059bf6d3e10a966eff97769dd77a441a29f32 into 249a0212295d6f0e463fbf62bb87e885dbba62e5\n"}},"249a0212295d6f0e463fbf62bb87e885dbba62e5":{"type":"commit","body":{"tree":"2a017e1e6af317af2de11e04f42d6b99a21caee5","parents":["60a948144071576f14e47eaa8d6a06cc929cfef1","06165d064052eb3cf4cd91facc8ef7f16d1859ad"],"author":"Tim Caswell <tim@creationix.com> 1374059807 -0700","committer":"Tim Caswell <tim@creationix.com> 1374059807 -0700","message":"Merge pull request #4 from chuckjaz/NewTests\n\nUnit tests for the callback parameter"}},"4c2be27f2f6e5bee6957eeaeb5e138b9030596aa":{"type":"commit","body":{"tree":"2a017e1e6af317af2de11e04f42d6b99a21caee5","parents":["60a948144071576f14e47eaa8d6a06cc929cfef1","06165d064052eb3cf4cd91facc8ef7f16d1859ad"],"author":"chuckjaz <chuckjaz@hotmail.com> 1374059746 -0700","committer":"chuckjaz <chuckjaz@hotmail.com> 1374059746 -0700","message":"Merge 06165d064052eb3cf4cd91facc8ef7f16d1859ad into 60a948144071576f14e47eaa8d6a06cc929cfef1\n"}},"60a948144071576f14e47eaa8d6a06cc929cfef1":{"type":"commit","body":{"tree":"27b0dbcc2df4f63190c29e197714ec2af79e9d36","parents":["e331c0bfd756a9df69edc0807950f8c988b1d968","b151ce453ad03e1cbbaa37240573b40ae39bb2b8"],"author":"Tim Caswell <tim@creationix.com> 1374059183 -0700","committer":"Tim Caswell <tim@creationix.com> 1374059183 -0700","message":"Merge pull request #3 from chuckjaz/SmallFix\n\nFixed a typo"}},"c607352347c38fb43c34613a3220e24667fb5a14":{"type":"commit","body":{"tree":"27b0dbcc2df4f63190c29e197714ec2af79e9d36","parents":["e331c0bfd756a9df69edc0807950f8c988b1d968","b151ce453ad03e1cbbaa37240573b40ae39bb2b8"],"author":"chuckjaz <chuckjaz@hotmail.com> 1374014288 -0700","committer":"chuckjaz <chuckjaz@hotmail.com> 1374014288 -0700","message":"Merge b151ce453ad03e1cbbaa37240573b40ae39bb2b8 into e331c0bfd756a9df69edc0807950f8c988b1d968\n"}},"b151ce453ad03e1cbbaa37240573b40ae39bb2b8":{"type":"commit","body":{"tree":"27b0dbcc2df4f63190c29e197714ec2af79e9d36","parents":["ad015d66210fdadb5d87b0248f16cfc40f648c3a"],"author":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1374014268 -0700","committer":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1374014268 -0700","message":"Fixing another typo\n"}},"06165d064052eb3cf4cd91facc8ef7f16d1859ad":{"type":"commit","body":{"tree":"6d91d275575fcb1b28bc1c8b1b63198089c79c70","parents":["e331c0bfd756a9df69edc0807950f8c988b1d968"],"author":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1374014167 -0700","committer":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1374014167 -0700","message":"Unit tests for the callback parameter\n"}},"e331c0bfd756a9df69edc0807950f8c988b1d968":{"type":"commit","body":{"tree":"734233129c7526ceb39505283d3852f220e54a39","parents":["09c03ff4f126a417853d21629c162f79f0f2d142"],"author":"Tim Caswell <tim@creationix.com> 1373903063 -0500","committer":"Tim Caswell <tim@creationix.com> 1373903063 -0500","message":"Add optional callback argument\n"}},"1a4da01a75fd0f2d80af1c0585bccfa54ca20d20":{"type":"commit","body":{"tree":"0bd2151caf3287f83bf55b7f3401456b3279109c","parents":["cf2accd6fa4fa4fdb818f35227e02faaa2dfc5b3"],"author":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1373765887 -0700","committer":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1373765887 -0700","message":"A smaller version of adding a callback\n"}},"5d1ce81dcb3a412221f034c55c152055cfc12ff5":{"type":"commit","body":{"tree":"0bd2151caf3287f83bf55b7f3401456b3279109c","parents":["09c03ff4f126a417853d21629c162f79f0f2d142","1a4da01a75fd0f2d80af1c0585bccfa54ca20d20"],"author":"chuckjaz <chuckjaz@hotmail.com> 1373765874 -0700","committer":"chuckjaz <chuckjaz@hotmail.com> 1373765874 -0700","message":"Merge 1a4da01a75fd0f2d80af1c0585bccfa54ca20d20 into 09c03ff4f126a417853d21629c162f79f0f2d142\n"}},"cf2accd6fa4fa4fdb818f35227e02faaa2dfc5b3":{"type":"commit","body":{"tree":"eebb35bc8886c5a6041fb3229f9ebc680ee3dbb9","parents":["09c03ff4f126a417853d21629c162f79f0f2d142"],"author":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1373765058 -0700","committer":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1373765058 -0700","message":"Added an optional callback parameter\n"}},"09c03ff4f126a417853d21629c162f79f0f2d142":{"type":"commit","body":{"tree":"2a77f00dde31cac45e3915d104d61593d1f6c9e4","parents":["d5af5828e3691a2e8b7a9ff7a2a8ed83ee5186b7"],"author":"Tim Caswell <tim@creationix.com> 1371158602 -0400","committer":"Tim Caswell <tim@creationix.com> 1371158602 -0400","message":"more s/thunks/continuables/ in README"}},"d5af5828e3691a2e8b7a9ff7a2a8ed83ee5186b7":{"type":"commit","body":{"tree":"2a570aa049d9fb48a0e1133becadd693b0177599","parents":["aa838baf16bb191ab5121b7741aa0a2f8800e74d"],"author":"Tim Caswell <tim@creationix.com> 1371136132 -0500","committer":"Tim Caswell <tim@creationix.com> 1371136132 -0500","message":"Update README.md"}},"aa838baf16bb191ab5121b7741aa0a2f8800e74d":{"type":"commit","body":{"tree":"f562d0c52d89277a074ad3de4399a38d0283f302","parents":["b8508bd0c3d6dfa16be2bcc069f5ceaa02ac1235"],"author":"Tim Caswell <tim@creationix.com> 1371079189 -0500","committer":"Tim Caswell <tim@creationix.com> 1371079189 -0500","message":"Update README.md"}},"b8508bd0c3d6dfa16be2bcc069f5ceaa02ac1235":{"type":"commit","body":{"tree":"1c629a7588bedd2504144c96325ebfa3459022ba","parents":["33b442399ef320a02ab3e69974a6e54d7128de6a"],"author":"Tim Caswell <tim@creationix.com> 1371037116 -0500","committer":"Tim Caswell <tim@creationix.com> 1371037116 -0500","message":"Document how to run test in package.json\n"}},"33b442399ef320a02ab3e69974a6e54d7128de6a":{"type":"commit","body":{"tree":"4b07a9bfaa23e06f3f879bf3d0d26dd6d3181054","parents":["9fac9debf0d8cb8943cc8f2ff9170469b70770b9"],"author":"Tim Caswell <tim@creationix.com> 1371037004 -0500","committer":"Tim Caswell <tim@creationix.com> 1371037004 -0500","message":"Rename thunk to continuable and fix typo in nowrap example\n"}},"9fac9debf0d8cb8943cc8f2ff9170469b70770b9":{"type":"commit","body":{"tree":"befb11ec0efd4a1b53d4bc16998caf7363e5051c","parents":["fb54c799d5b7fec04d2012c0da0fc89a88e52aa5"],"author":"Tim Caswell <tim@creationix.com> 1371034563 -0500","committer":"Tim Caswell <tim@creationix.com> 1371034563 -0500","message":"Add license to README\n"}},"fb54c799d5b7fec04d2012c0da0fc89a88e52aa5":{"type":"commit","body":{"tree":"9cf81764b574ea991097969fd9d27497af45d5a7","parents":["6def309873599c8c803c842f64aba6b2f44a2d6c"],"author":"Tim Caswell <tim@creationix.com> 1371034433 -0500","committer":"Tim Caswell <tim@creationix.com> 1371034433 -0500","message":"Fix missing yield in README\n"}},"6def309873599c8c803c842f64aba6b2f44a2d6c":{"type":"commit","body":{"tree":"8aa1144854bf4f9d07ac62a80b583979cbd64425","parents":["b4ca2abaf6619506e6427e530536ca1b9fe4f082"],"author":"Tim Caswell <tim@creationix.com> 1371034138 -0500","committer":"Tim Caswell <tim@creationix.com> 1371034138 -0500","message":"Add docs\n"}},"b4ca2abaf6619506e6427e530536ca1b9fe4f082":{"type":"commit","body":{"tree":"9f89bc2b115baee2f28db9ae0654c1d7bf2db6f4","parents":["698b61d447f35e3713f941c1bd17352d24f516db"],"author":"Tim Caswell <tim@creationix.com> 1371032374 -0500","committer":"Tim Caswell <tim@creationix.com> 1371032374 -0500","message":"Add code and npm package.json\n"}},"698b61d447f35e3713f941c1bd17352d24f516db":{"type":"commit","body":{"tree":"71a43aaf274537bf5216302d9580b2105f9eea18","author":"Tim Caswell <tim@creationix.com> 1371053470 -0700","committer":"Tim Caswell <tim@creationix.com> 1371053470 -0700","message":"Initial commit\n"}},"69eaefd51eb7a12beea12c9c51d80df683713168":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"eb02eab584ea476f8518a58f460c2fe46ef420ed"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"e505aa8aac07b7bcf9c7f35624a01802ade81115"},{"mode":33188,"name":"test.js","hash":"fa5eaa03431c1ca1be883041aac15ffd9815938b"}]},"d611852a71841ef6aefcc0c4e07bb5f71a4703a5":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"89f03e899333175d9a97978f60f9854ae4b35bfe"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"b0b716a51f986d3101d090a118740f22982c98be"},{"mode":33188,"name":"test.js","hash":"8d1dbcf6b814b2d14722c8c1d6e946aebfcdd5e7"}]},"27b0dbcc2df4f63190c29e197714ec2af79e9d36":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"eb02eab584ea476f8518a58f460c2fe46ef420ed"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"74b1a93637341761a01c9db124a0d6ab5acde921"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"6d91d275575fcb1b28bc1c8b1b63198089c79c70":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"eb02eab584ea476f8518a58f460c2fe46ef420ed"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"c5ed2ee8286110db7bf77dd59803ba4bb731b56f"},{"mode":33188,"name":"test.js","hash":"32bde81e5d29812fe00f7216bb6de22f5d9420dd"}]},"0bd2151caf3287f83bf55b7f3401456b3279109c":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"f53a5d00173353a8e69cc6ad2bef108823416b37"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"6972fd725a526cacdcfcee7f14955cc80d49bb25"},{"mode":33188,"name":"test.js","hash":"32bde81e5d29812fe00f7216bb6de22f5d9420dd"}]},"2a77f00dde31cac45e3915d104d61593d1f6c9e4":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"6cda1e03c2a65e8f95b638144fe0e33efa67547c"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"2a570aa049d9fb48a0e1133becadd693b0177599":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"9dd106df0477a663f155ed1d792e448e65ebf903"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"f562d0c52d89277a074ad3de4399a38d0283f302":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"b8afa660b60b152012a00b48ef4e1a7f503ffadf"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"1c629a7588bedd2504144c96325ebfa3459022ba":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"4ad794eb530e8e84f7cf57cd54fd349007d3d4e0"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"befb11ec0efd4a1b53d4bc16998caf7363e5051c":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"73df94f4aeccec1c810a52382121232be1fb940e"},{"mode":33188,"name":"package.json","hash":"7a7d73c922f3d46306b2e6d03e2f327ccfde0a58"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"}]},"9cf81764b574ea991097969fd9d27497af45d5a7":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"97515904ad00940ca5d12840b75959e89dbd007f"},{"mode":33188,"name":"package.json","hash":"7a7d73c922f3d46306b2e6d03e2f327ccfde0a58"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"}]},"8aa1144854bf4f9d07ac62a80b583979cbd64425":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"ffed989a8babac952bd759a9d1c1531f975bf0e5"},{"mode":33188,"name":"package.json","hash":"7a7d73c922f3d46306b2e6d03e2f327ccfde0a58"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"}]},"9f89bc2b115baee2f28db9ae0654c1d7bf2db6f4":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"c696eafb58bace80284acdac4bc22a77695fd721"},{"mode":33188,"name":"package.json","hash":"7a7d73c922f3d46306b2e6d03e2f327ccfde0a58"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"}]},"71a43aaf274537bf5216302d9580b2105f9eea18":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"c696eafb58bace80284acdac4bc22a77695fd721"}]},"f53a5d00173353a8e69cc6ad2bef108823416b37":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and [continuables](https://github.com/creationix/js-git/blob/master/specs/continuable.md).\n\nSupports both async functions that use node-style callbacks and continuable-returning async functions.\n\n## What is a Continuable?\n\nA \"continuable\" is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a continuable instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\nIf you pass a second parameter to `run()` it will call the function back with the return result of the function. For example,\n\n```js\nrun(function *() {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n  return \"Hello World\";  \n}, function (err, value) {\n  if (err) console.log(\"Error encountered: \" + err);\n  else console.log(value);\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding continuables to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the continuable function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil functions that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same continuable.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the continuable will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a continuable style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports continuables or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with continuable style APIs.  If you yield a function, it will assume it's a continuable and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"7a7d73c922f3d46306b2e6d03e2f327ccfde0a58":{"type":"blob","body":"{\n  \"name\": \"gen-run\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Generator Async Runner. Makes it possible to yield and wait for callbacks and thunks.\",\n  \"main\": \"run.js\",\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/gen-run.git\"\n  },\n  \"keywords\": [\n    \"generator\",\n    \"async\",\n    \"runner\",\n    \"thunk\",\n    \"continuable\",\n    \"callback\"\n  ],\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"license\": \"MIT\",\n  \"readmeFilename\": \"README.md\",\n  \"bugs\": {\n    \"url\": \"https://github.com/creationix/gen-run/issues\"\n  }\n}\n"},"b0b716a51f986d3101d090a118740f22982c98be":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  // Pass in gen for no-wrap function calls\n  var iterator = generator(gen);\n  var data = null, yielded = false, calledGen = false;\n\n  if (!callback) callback = function (err) {\n    // If the generator ended with an error, throw it globally with setTimeout.\n    // Throwing locally from a callback is not allowed, and swallowing the\n    // error is a bad idea, so there's no better option.\n    if (err) setTimeout(function () { throw err; }, 0);\n  };\n\n  next();\n  check();\n  \n  function next(err, item) {\n    var n;\n    try {\n      n = (err ? iterator.throw(err) : iterator.next(item));\n      if (!n.done) {\n        if (!calledGen && typeof n.value === \"function\") n.value(gen());\n        if (!calledGen) {\n          throw Error(\"generator didn't yield a continuable or call gen()\");\n        }\n        yielded = true;\n        return;\n      }\n    }\n    catch (err) {\n      return callback(err);\n    }\n    return callback(null, n.value);\n  }\n  \n  function gen() {\n    if (yielded) throw Error(\"gen() can only be called from the generator\");\n    if (calledGen) throw Error(\"gen() already called\");\n    calledGen = true;\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n  \n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      calledGen = false;\n      next(err, item);\n    }\n  }\n\n}\n"},"fa5eaa03431c1ca1be883041aac15ffd9815938b":{"type":"blob","body":"var run = require('./.');\n\nfunction testRun(name, fn) {\n  console.log(\"\\nStarting\", name);\n  run(fn);\n  console.log(\"Started\", name);\n}\n\ntestRun(\"basic\", basic);\n\nfunction* basic() {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"delegating\", delegating);\n}\n\nfunction* delegating() {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n  testRun(\"sync\", sync);\n}\n\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nfunction* sync() {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n  testRun(\"multi\", multi);\n}\n\nfunction* multi() {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"nowrap\", nowrap);\n}\n\nfunction* nowrap(gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n  testRun(\"nowrap_delegating\", nowrap_delegating);\n}\n\nfunction* nowrap_delegating(gen) {\n  console.log(\"Start\");\n  yield* nowrap_sub(gen, 10);\n  testRun(\"run_with_callback\", run_with_callback);\n}\n\nfunction* nowrap_sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n  console.log(\"DONE!\");\n}\n\nfunction *run_with_callback(gen) {\n  console.log(\"Callback\");\n  yield run(function* (gen) {\n    yield sleep(1000);\n    return \"Hello\";\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    gen()(err, value);\n  });\n  testRun(\"run_with_callback_exception\", run_with_callback_exception);\n}\n\nfunction *run_with_callback_exception(gen) {\n  console.log(\"Callback err\");\n  yield run(function *(gen) {\n    yield sleep(1000);\n    throw new Error(\"Some error\");\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    gen()(null, value); // Intentionally suppress the error\n  });\n  testRun(\"run_with_callback_early_exception\", run_with_callback_early_exception);\n}\n\nfunction *run_with_callback_early_exception(gen) {\n  console.log(\"Callback err\");\n  yield run(function *(gen) {\n    throw new Error(\"Some error\");\n    yield sleep(1000);\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    gen()(null, value); // Intentionally suppress the error\n  });\n  testRun(\"run_with_thrown_error\", run_with_thrown_error);\n}\n\nfunction *run_with_thrown_error(gen) {\n  var inCatch = false;\n  try {\n    yield sleep(1);\n    yield fail();\n    console.error(\"this should not happen!\");\n  }\n  catch (err) {\n    console.log(\"in catch: \" + err);\n    console.assert(err);\n    inCatch = true;\n  }\n  yield sleep(1);\n  console.log(\"yielded after catch\");\n  console.assert(inCatch);\n  console.log(\"\\nEnd\");\n}\n\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  };\n}\n\nfunction fail() {\n  return function (callback) {\n    callback(Error(\"throwing error into generator\"));\n  };\n}\n\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n"},"598eb6a403fb151046626acc826cc8afa62e664c":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n  var next;\n\n  if (callback)\n    next = function next(item) {\n      try {\n        var cont = iterator.next(item);\n        if (cont.done) \n          callback(null, cont.value);\n        else {\n          if (typeof cont.value === \"function\") cont.value(resume());\n          yielded = true;\n        }\n      }\n      catch (e) {\n        callback(e, null);\n      }\n    }\n  else\n    next = function next(item) {\n      var cont = iterator.next(item).value;\n      // Pass in resume to continuables if one was yielded.\n      if (typeof cont === \"function\") cont(resume());\n      yielded = true;\n    }\n\n  next();\n  check();\n\n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n\n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      if (err) return iterator.throw(err);\n      next(item);\n      yielded = true;\n    }\n  }\n}\n"},"c696eafb58bace80284acdac4bc22a77695fd721":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and thunks.,\n"},"4b07a9bfaa23e06f3f879bf3d0d26dd6d3181054":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"4ad794eb530e8e84f7cf57cd54fd349007d3d4e0"},{"mode":33188,"name":"package.json","hash":"7a7d73c922f3d46306b2e6d03e2f327ccfde0a58"},{"mode":33188,"name":"run.js","hash":"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"eebb35bc8886c5a6041fb3229f9ebc680ee3dbb9":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"f53a5d00173353a8e69cc6ad2bef108823416b37"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"598eb6a403fb151046626acc826cc8afa62e664c"},{"mode":33188,"name":"test.js","hash":"32bde81e5d29812fe00f7216bb6de22f5d9420dd"}]},"734233129c7526ceb39505283d3852f220e54a39":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"eb02eab584ea476f8518a58f460c2fe46ef420ed"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"c5ed2ee8286110db7bf77dd59803ba4bb731b56f"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"2a017e1e6af317af2de11e04f42d6b99a21caee5":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"eb02eab584ea476f8518a58f460c2fe46ef420ed"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"74b1a93637341761a01c9db124a0d6ab5acde921"},{"mode":33188,"name":"test.js","hash":"32bde81e5d29812fe00f7216bb6de22f5d9420dd"}]},"6972fd725a526cacdcfcee7f14955cc80d49bb25":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  if (callback) {\n    return run(function *(gen) {\n      try {\n        callback(null, yield *generator(gen));\n      }\n      catch(err) {\n        callback(err);\n      }\n    });\n  }\n\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n\n  next();\n  check();\n\n  function next(item) {\n    var cont = iterator.next(item).value;\n    // Pass in resume to continuables if one was yielded.\n    if (typeof cont === \"function\") cont(resume());\n    yielded = true;\n  }\n\n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n\n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      if (err) return iterator.throw(err);\n      next(item);\n      yielded = true;\n    }\n  }\n}\n"},"36df54dc250788758475dac220dd841b7a6ded48":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n\n  var next = callback ? nextSafe : nextPlain;\n  \n  next();\n  check();\n  \n  function nextSafe(item) {\n    var n;\n    try {\n      n = iterator.next(item);\n      if (!n.done) {\n        if (typeof n.value === \"function\") n.value(resume());\n        yielded = true;\n        return;\n      }\n    }\n    catch (err) {\n      return callback(err);\n    }\n    return callback(null, n.value());\n  }\n\n  function nextPlain(item) {\n    var cont = iterator.next(item).value;\n    // Pass in resume to continuables if one was yielded.\n    if (typeof cont === \"function\") cont(resume());\n    yielded = true;\n  }\n  \n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n  \n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      if (err) return iterator.throw(err);\n      next(item);\n      yielded = true;\n    }\n  }\n\n}\n"},"32bde81e5d29812fe00f7216bb6de22f5d9420dd":{"type":"blob","body":"var run = require('./.');\n\nfunction testRun(name, fn) {\n  console.log(\"\\nStarting\", name);\n  run(fn);\n  console.log(\"Started\", name);\n}\n\ntestRun(\"basic\", basic);\n\nfunction* basic() {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"delegating\", delegating);\n}\n\nfunction* delegating() {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n  testRun(\"sync\", sync);\n}\n\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nfunction* sync() {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n  testRun(\"multi\", multi);\n}\n\nfunction* multi() {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"nowrap\", nowrap);\n}\n\nfunction* nowrap(gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n  testRun(\"nowrap_delegating\", nowrap_delegating);\n}\n\nfunction* nowrap_delegating(gen) {\n  console.log(\"Start\");\n  yield* nowrap_sub(gen, 10);\n  testRun(\"run_with_callback\", run_with_callback);\n}\n\nfunction* nowrap_sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n  console.log(\"DONE!\");\n}\n\nfunction *run_with_callback(gen) {\n  console.log(\"Callback\");\n  yield run(function* (gen) {\n    yield sleep(1000);\n    return \"Hello\"\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    gen()(err, value);\n  });\n  testRun(\"run_with_callback_exception\", run_with_callback_exception);\n}\n\nfunction *run_with_callback_exception(gen) {\n  console.log(\"Callback err\");\n  yield run(function *(gen) {\n    yield sleep(1000);\n    throw new Error(\"Some error\");\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    gen()(null, value); // Intentionally suppress the error\n  });\n  testRun(\"run_with_callback_early_exception\", run_with_callback_early_exception);\n}\n\nfunction *run_with_callback_early_exception(gen) {\n  console.log(\"Callback err\");\n  yield run(function *(gen) {\n    throw new Error(\"Some error\");\n    yield sleep(1000);\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    gen()(null, value); // Intentionally suppress the error\n  });\n  console.log(\"End\");\n}\n\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n"},"8d1dbcf6b814b2d14722c8c1d6e946aebfcdd5e7":{"type":"blob","body":"var run = require('./.');\n\nfunction testRun(name, fn) {\n  console.log(\"\\nStarting\", name);\n  run(fn);\n  console.log(\"Started\", name);\n}\n\ntestRun(\"basic\", basic);\n\nfunction* basic() {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"delegating\", delegating);\n}\n\nfunction* delegating() {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n  testRun(\"sync\", sync);\n}\n\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nfunction* sync() {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n  testRun(\"multi\", multi);\n}\n\nfunction* multi() {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"nowrap\", nowrap);\n}\n\nfunction* nowrap(gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n  testRun(\"nowrap_delegating\", nowrap_delegating);\n}\n\nfunction* nowrap_delegating(gen) {\n  console.log(\"Start\");\n  yield* nowrap_sub(gen, 10);\n  testRun(\"run_with_callback\", run_with_callback);\n}\n\nfunction* nowrap_sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n  console.log(\"DONE!\");\n}\n\nfunction *run_with_callback(gen) {\n  console.log(\"Callback\");\n  var resume = gen();\n  yield run(function* (gen) {\n    yield sleep(1000);\n    return \"Hello\";\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    resume(err, value);\n  });\n  testRun(\"run_with_callback_exception\", run_with_callback_exception);\n}\n\nfunction *run_with_callback_exception(gen) {\n  console.log(\"Callback err\");\n  var resume = gen();\n  yield run(function *(gen) {\n    yield sleep(1000);\n    throw new Error(\"Some error\");\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    resume(null, value); // Intentionally suppress the error\n  });\n  testRun(\"run_with_callback_early_exception\", run_with_callback_early_exception);\n}\n\nfunction *run_with_callback_early_exception(gen) {\n  console.log(\"Callback err\");\n  var resume = gen();\n  yield run(function *(gen) {\n    throw new Error(\"Some error\");\n    yield sleep(1000);\n  }, function (err, value) {\n    console.log(\"Callback err: \" + err);\n    console.log(\"Callback value: \" + value);\n    resume(null, value); // Intentionally suppress the error\n  });\n  testRun(\"run_with_thrown_error\", run_with_thrown_error);\n}\n\nfunction *run_with_thrown_error(gen) {\n  var inCatch = false;\n  try {\n    yield sleep(1);\n    yield fail();\n    console.error(\"this should not happen!\");\n  }\n  catch (err) {\n    console.log(\"in catch: \" + err);\n    console.assert(err);\n    inCatch = true;\n  }\n  yield sleep(1);\n  console.log(\"yielded after catch\");\n  console.assert(inCatch);\n  console.log(\"\\nEnd\");\n}\n\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  };\n}\n\nfunction fail() {\n  return function (callback) {\n    callback(Error(\"throwing error into generator\"));\n  };\n}\n\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n"},"f3997f0f892e577eeb47ed290fefbe6535ff576f":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n\n  if (!callback) callback = function (err) {\n    // If the generator ended with an error, throw it globally with setTimeout.\n    // Throwing locally from a callback is not allowed, and swallowing the\n    // error is a bad idea, so there's no better option.\n    if (err) setTimeout(function () { throw err; }, 0);\n  };\n\n  next();\n  check();\n  \n  function next(err, item) {\n    var n;\n    try {\n      n = (err ? iterator.throw(err) : iterator.next(item));\n      if (!n.done) {\n        if (typeof n.value === \"function\") n.value(resume());\n        yielded = true;\n        return;\n      }\n    }\n    catch (err) {\n      return callback(err);\n    }\n    return callback(null, n.value);\n  }\n  \n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n  \n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      next(err, item);\n      yielded = true;\n    }\n  }\n\n}\n"},"25c1fa7823da8c98123078cb83cde5f0e7d56b1a":{"type":"blob","body":"{\n  \"name\": \"gen-run\",\n  \"version\": \"0.1.0\",\n  \"description\": \"Generator Async Runner. Makes it possible to yield and wait for callbacks and thunks.\",\n  \"main\": \"run.js\",\n  \"scripts\": {\n    \"test\": \"node --harmony_generators test.js\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/creationix/gen-run.git\"\n  },\n  \"keywords\": [\n    \"generator\",\n    \"async\",\n    \"runner\",\n    \"thunk\",\n    \"continuable\",\n    \"callback\"\n  ],\n  \"author\": \"Tim Caswell <tim@creationix.com>\",\n  \"license\": \"MIT\",\n  \"readmeFilename\": \"README.md\",\n  \"bugs\": {\n    \"url\": \"https://github.com/creationix/gen-run/issues\"\n  }\n}\n"},"9dd106df0477a663f155ed1d792e448e65ebf903":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and [continuables](https://github.com/creationix/js-git/blob/master/specs/continuable.md).\n\nSupports both async functions that use node-style callbacks and continuable-returning async functions.\n\n## What is a Continuable?\n\nA \"continuable\" is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a continuable instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding thunks to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the continuable function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil functions that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same continuable.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the continuable will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a continuable style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports thunks or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with continuable style APIs.  If you yield a function, it will assume it's a continuable and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"6cda1e03c2a65e8f95b638144fe0e33efa67547c":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and [continuables](https://github.com/creationix/js-git/blob/master/specs/continuable.md).\n\nSupports both async functions that use node-style callbacks and continuable-returning async functions.\n\n## What is a Continuable?\n\nA \"continuable\" is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a continuable instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding continuables to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the continuable function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil functions that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same continuable.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the continuable will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a continuable style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports continuables or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with continuable style APIs.  If you yield a function, it will assume it's a continuable and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"eb02eab584ea476f8518a58f460c2fe46ef420ed":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and [continuables](https://github.com/creationix/js-git/blob/master/specs/continuable.md).\n\nSupports both async functions that use node-style callbacks and continuable-returning async functions.\n\n## What is a Continuable?\n\nA \"continuable\" is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a continuable instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\nIf you pass a second parameter to `run()` it will call the function back with the return result of the function. For example,\n\n```js\nrun(function *() {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n  return \"Hello World\";\n}, function (err, value) {\n  if (err) console.log(\"Error encountered: \" + err);\n  else console.log(value);\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding continuables to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the continuable function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil functions that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same continuable.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the continuable will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a continuable style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports continuables or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with continuable style APIs.  If you yield a function, it will assume it's a continuable and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"8e6a1db11e855f48ec5204e8a78795f322f02904":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"eb02eab584ea476f8518a58f460c2fe46ef420ed"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"f3997f0f892e577eeb47ed290fefbe6535ff576f"},{"mode":33188,"name":"test.js","hash":"fa5eaa03431c1ca1be883041aac15ffd9815938b"}]},"ad015d66210fdadb5d87b0248f16cfc40f648c3a":{"type":"commit","body":{"tree":"9ff648c9d857991965258d0671a4e899d874731b","parents":["e331c0bfd756a9df69edc0807950f8c988b1d968"],"author":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1374012844 -0700","committer":"Chuck Jazdzewski <chuckjaz@hotmail.com> 1374012844 -0700","message":"Fixed a typo\n"}},"337059bf6d3e10a966eff97769dd77a441a29f32":{"type":"commit","body":{"tree":"69eaefd51eb7a12beea12c9c51d80df683713168","parents":["249a0212295d6f0e463fbf62bb87e885dbba62e5"],"author":"Tomi Belan <tomi.belan@gmail.com> 1377382399 -0700","committer":"Tomi Belan <tomi.belan@gmail.com> 1377382550 -0700","message":"Fix throwing errors into the generator\n\nFixes issue #5\n"}},"89f03e899333175d9a97978f60f9854ae4b35bfe":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and [continuables](https://github.com/creationix/js-git/blob/master/specs/continuable.md).\n\nSupports both async functions that use node-style callbacks and continuable-returning async functions.\n\n## What is a Continuable?\n\nA \"continuable\" is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a continuable instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\nIf you pass a second parameter to `run()` it will call the function back with the return result of the function. For example,\n\n```js\nrun(function *() {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n  return \"Hello World\";\n}, function (err, value) {\n  if (err) console.log(\"Error encountered: \" + err);\n  else console.log(value);\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding continuables to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the continuable function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil functions that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same continuable.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the continuable will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a continuable style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports continuables or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with continuable style APIs.  If you call `gen()`, you still have to yield afterwards, but the actual yielded value will be ignored.  If you don't call `gen()`, you have to yield a continuable function, which will be called by gen-run appropriately.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"4ad794eb530e8e84f7cf57cd54fd349007d3d4e0":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and thunks.,\n\nSupports both async functions that use node-style callbacks and continuable-returning async functions.\n\n## What is a Continuable?\n\nA \"continuable\" is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a continuable instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding thunks to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the continuable function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil thunks that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same continuable.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the continuable will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a continuable style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports thunks or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with continuable style APIs.  If you yield a function, it will assume it's a continuable and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"b8afa660b60b152012a00b48ef4e1a7f503ffadf":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and [continuables](https://github.com/creationix/js-git/blob/master/specs/continuable.md).\n\nSupports both async functions that use node-style callbacks and continuable-returning async functions.\n\n## What is a Continuable?\n\nA \"continuable\" is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a continuable instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding thunks to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the continuable function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil thunks that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same continuable.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the continuable will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a continuable style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports thunks or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with continuable style APIs.  If you yield a function, it will assume it's a continuable and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n> The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632":{"type":"blob","body":"var run = require('./.');\n\nfunction testRun(name, fn) {\n  console.log(\"\\nStarting\", name);\n  run(fn);\n  console.log(\"Started\", name);\n}\n\ntestRun(\"basic\", basic);\n\nfunction* basic() {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"delegating\", delegating);\n}\n\nfunction* delegating() {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n  testRun(\"sync\", sync);\n}\n\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nfunction* sync() {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n  testRun(\"multi\", multi);\n}\n\nfunction* multi() {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n  testRun(\"nowrap\", nowrap);\n}\n\nfunction* nowrap(gen) {\n  console.log(\"Hello\");\n  yield setTimeout(gen(), 1000);\n  console.log(\"World\");\n  testRun(\"nowrap_delegating\", nowrap_delegating);\n}\n\nfunction* nowrap_delegating(gen) {\n  console.log(\"Start\");\n  yield* nowrap_sub(gen, 10);\n  console.log(\"End\");\n\n}\n\nfunction* nowrap_sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n  console.log(\"DONE!\");\n}\n\n\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\n"},"4e631ccfe5c1739c43ba666331cde1c9c4e3dc84":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator) {\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n  \n  next();\n  check();\n  \n  function next(item) {\n    var cont = iterator.next(item).value;\n    // Pass in resume to continuables if one was yielded.\n    if (typeof cont === \"function\") cont(resume());\n    yielded = true;\n  }\n  \n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n  \n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      if (err) return iterator.throw(err);\n      next(item);\n      yielded = true;\n    }\n  }\n\n}\n"},"c5ed2ee8286110db7bf77dd59803ba4bb731b56f":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n\n  var next = callback ? nextSafe : nextPlain;\n  \n  next();\n  check();\n  \n  function nextSafe(item) {\n    var n;\n    try {\n      n = iterator.next(item);\n      if (!n.done) {\n        if (typeof n.value === \"function\") n.value(resume());\n        yielded = true;\n        return;\n      }\n    }\n    catch (err) {\n      return callback(err);\n    }\n    return callback(null, n.value();\n  }\n\n  function nextPlain(item) {\n    var cont = iterator.next(item).value;\n    // Pass in resume to continuables if one was yielded.\n    if (typeof cont === \"function\") cont(resume());\n    yielded = true;\n  }\n  \n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n  \n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      if (err) return iterator.throw(err);\n      next(item);\n      yielded = true;\n    }\n  }\n\n}\n"},"74b1a93637341761a01c9db124a0d6ab5acde921":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n\n  var next = callback ? nextSafe : nextPlain;\n  \n  next();\n  check();\n  \n  function nextSafe(item) {\n    var n;\n    try {\n      n = iterator.next(item);\n      if (!n.done) {\n        if (typeof n.value === \"function\") n.value(resume());\n        yielded = true;\n        return;\n      }\n    }\n    catch (err) {\n      return callback(err);\n    }\n    return callback(null, n.value);\n  }\n\n  function nextPlain(item) {\n    var cont = iterator.next(item).value;\n    // Pass in resume to continuables if one was yielded.\n    if (typeof cont === \"function\") cont(resume());\n    yielded = true;\n  }\n  \n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n  \n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      if (err) return iterator.throw(err);\n      next(item);\n      yielded = true;\n    }\n  }\n\n}\n"},"9ff648c9d857991965258d0671a4e899d874731b":{"type":"tree","body":[{"mode":33188,"name":"README.md","hash":"eb02eab584ea476f8518a58f460c2fe46ef420ed"},{"mode":33188,"name":"package.json","hash":"25c1fa7823da8c98123078cb83cde5f0e7d56b1a"},{"mode":33188,"name":"run.js","hash":"36df54dc250788758475dac220dd841b7a6ded48"},{"mode":33188,"name":"test.js","hash":"0deaff4e72c4489656cbe3a97e1f5dd6a6f1d632"}]},"e505aa8aac07b7bcf9c7f35624a01802ade81115":{"type":"blob","body":"module.exports = run;\n\nfunction run(generator, callback) {\n  // Pass in resume for no-wrap function calls\n  var iterator = generator(resume);\n  var data = null, yielded = false;\n\n  var next = callback ? nextSafe : nextPlain;\n  \n  next();\n  check();\n  \n  function nextSafe(err, item) {\n    var n;\n    try {\n      n = (err ? iterator.throw(err) : iterator.next(item));\n      if (!n.done) {\n        if (typeof n.value === \"function\") n.value(resume());\n        yielded = true;\n        return;\n      }\n    }\n    catch (err) {\n      return callback(err);\n    }\n    return callback(null, n.value);\n  }\n\n  function nextPlain(err, item) {\n    var cont = (err ? iterator.throw(err) : iterator.next(item)).value;\n    // Pass in resume to continuables if one was yielded.\n    if (typeof cont === \"function\") cont(resume());\n    yielded = true;\n  }\n  \n  function resume() {\n    var done = false;\n    return function () {\n      if (done) return;\n      done = true;\n      data = arguments;\n      check();\n    };\n  }\n  \n  function check() {\n    while (data && yielded) {\n      var err = data[0];\n      var item = data[1];\n      data = null;\n      yielded = false;\n      next(err, item);\n      yielded = true;\n    }\n  }\n\n}\n"},"73df94f4aeccec1c810a52382121232be1fb940e":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and thunks.,\n\nSupports both async functions that use node-style callbacks and thunk-returning async functions.\n\n## What is a Thunk?\n\nA \"thunk\" is also known as a \"continuable\" and is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a thunk instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding thunks to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the thunk function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil thunks that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same thunk.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the thunk will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a thunk style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports thunks or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with thunk style APIs.  If you yield a function, it will assume it's a thunk and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n## License\n\nThe MIT License (MIT)\n\nCopyright (c) 2013 Tim Caswell\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n"},"ffed989a8babac952bd759a9d1c1531f975bf0e5":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and thunks.,\n\nSupports both async functions that use node-style callbacks and thunk-returning async functions.\n\n## What is a Thunk?\n\nA \"thunk\" is also known as a \"continuable\" and is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a thunk instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding thunks to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the thunk function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil thunks that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same thunk.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the thunk will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a thunk style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports thunks or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with thunk style APIs.  If you yield a function, it will assume it's a thunk and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n\n"},"97515904ad00940ca5d12840b75959e89dbd007f":{"type":"blob","body":"gen-run\n=======\n\nGenerator Async Runner.  Makes it possible to yield and wait for callbacks and thunks.,\n\nSupports both async functions that use node-style callbacks and thunk-returning async functions.\n\n## What is a Thunk?\n\nA \"thunk\" is also known as a \"continuable\" and is simply a function that accepts a node style callback as it's only argument.\n\nA simple example is turning the `setTimeout` function to return a thunk instead of accepting a callback.\n\n```js\nfunction sleep(ms) {\n  return function (callback) {\n    setTimeout(callback, ms);\n  };\n}\n```\n\n## Using `run()`\n\nHere is an example using ES6 generators with the `gen-run` library to implement sleep.\n\n```js\nvar run = require('gen-run');\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Delegating Yield\n\nSince this works by yielding thunks to the run function, delegating yield will also \"just work\".\n\n```js\nfunction* sub(n) {\n  while (n) {\n    console.log(n--);\n    yield sleep(10);\n  }\n}\n\nrun(function* () {\n  console.log(\"Start\");\n  yield* sub(10);\n  console.log(\"End\");\n});\n```\n\n## Synchronous Callback Protection\n\nThe runner is aware that sometimes callbacks may be called before the thunk function returns and has safeguards internally to prevent stack overflows.\n\n```js\nfunction decrement(n) {\n  return function (callback) {\n    callback(null, n - 1);\n  };\n}\n\nrun(function* () {\n  var i = 100000;\n  while (i) {\n    i = yield decrement(i);\n  }\n});\n```\n\n## Multi-Callback Protection\n\nThere is also protection from evil thunks that may call the callback multiple times when they should only ever call it once.  Run will simply ignore subsequent calls from the same thunk.\n\n```js\nfunction evil() {\n  return function (callback) {\n    callback(null, 1);\n    setTimeout(function () {\n      callback(null, 2);\n    }, 100);\n  }\n}\n\nrun(function* () {\n  console.log(\"Hello\");\n  yield evil();\n  yield sleep(1000);\n  console.log(\"World\");\n});\n```\n\n## Error Handling\n\nI assume the callback in the thunk will be of the form `(err, item)` and will return the item as the result of yield or throw `err` into the generator.  This means that you can use async functions as if they were normal sync functions.\n\n```js\n// Wrap fs.readFile as a thunk style function.\n// Also intercept ENOENT errors and instead return undefined for the result\nfunction readFile(path, encoding) {\n  return function (callback) {\n    fs.readFile(path, encoding, function (err, data) {\n      if (err) {\n        if (err.code === \"ENOENT\") return callback();\n        return callback(err);\n      }\n      return callback(null, data);\n    });\n  };\n}\n\nrun(function* () {\n  try {\n    var contents = yield readFile(\"/myfile.txt\", \"utf8\");\n    if (contents) {\n      // the file existed and was not empty\n    }\n  }\n  catch (err) {\n    // There was a problem reading the file, but it did exist.\n  }\n});\n```\n\n## What about Parallel Work?\n\nLike the other libraries, I feel that doing parallel work it outside the scope of this tiny library.  It will work great with any control-flow library that supports thunks or callbacks.\n\n## But ES6 isn't everywhere yet.\n\nThat's OK. In node.js land, you can require your users or your app's deployment to use a certain version of node.js that has generators.  But for browsers and older versions of node there are transpilers.  <https://github.com/google/traceur-compiler>, for example can convert ES6 generator code to vanilla ES5 code.\n\n## Do I have to wrap everything I use then?\n\nNo, gen-run also works with any callback based API using a slightly more explicit syntax.\n\n```js\nrun(function* (gen) {\n  console.log(\"Hello\");\n  setTimeout(gen(), 1000);\n  console.log(\"World\");\n});\n```\n\nThis alternate API can be mixed and matched with thunk style APIs.  If you yield a function, it will assume it's a thunk and pass in a callback.  If you don't, it's your responsibility to pass in the generated callback manually in the right place.\n\nIf you want to use delegate yield with the explicit style it's up to you to pass the `gen` function to the child generator.\n\n```js\nfunction* sub(gen, n) {\n  while (n) {\n    console.log(n--);\n    yield setTimeout(gen(), 10);\n  }\n}\n\nrun(function* (gen) {\n  console.log(\"Start\");\n  yield* sub(gen, 10);\n  console.log(\"End\");\n});\n```\n\n## Credits\n\nThis library is the result of my lua research and researching many other similair libraries and taking the parts I like from them.  Libraries I took inspiration from are:\n\n - <https://github.com/visionmedia/co>\n - <https://github.com/jmar777/suspend>\n - <https://gist.github.com/Benvie/5667557#file-usage-js>\n - <https://github.com/spion/genny>\n\n\n"}}}