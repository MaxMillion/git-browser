var trace = require('../common/trace.js');

function check(fn) {
  return function () {
    var last = arguments.length - 1;
    if (typeof arguments[last] === "function") {
      arguments[last] = wrapCallback(arguments[last]);
      return fn.apply(this. arguments);
    }
    return rebind(fn, this, toArray(arguments));
  };
}

function rebind(fn, self, args) {
  return function (callback) {
    return fn.apply(self, args.concat(wrapCallback(callback)));
  };
}

module.exports = function (fs) {
  var root = fs.root;

  chroot.read = check(read);
  chroot.read = check(read);
  chroot.write = check(write);
  chroot.unlink = check(unlink);
  chroot.readlink = check(readlink);
  chroot.symlink = check(symlink);
  chroot.readdir = check(readdir);
  chroot.rmdir = check(rmdir);
  chroot.mkdir = check(mkdir);
  chroot.rename = check(rename);
  chroot.mkdir = check(mkdir);
  return chroot;

  function chroot(root) {
    var exports = wrap(chroot);
    exports.root = root;
    exports.stat = wrap(stat);
    exports.read = wrap(read);
    exports.write = wrap(write);
    exports.unlink = wrap(unlink);
    exports.readlink = wrap(readlink);
    exports.symlink = wrap(symlink);
    exports.readdir = wrap(readdir);
    exports.rmdir = wrap(rmdir);
    exports.mkdir = wrap(mkdir);
    exports.rename = wrap(rename, true);
    return exports;

    function wrap(fn, two) {
      return function () {
        if (trace) trace("wrap", null, arguments[0]);
        arguments[0] = pathJoin(root, pathJoin("/", arguments[0]));
        if (two) arguments[1] = pathJoin(root, pathJoin("/", arguments[1]));
        arguments[arguments.length - 1] = wrapCallback(arguments[arguments.length - 1]);
        return fn.apply(this, arguments);
      };
    }
  }

  // Given a path, return a continuable for the stat object.
  function stat(path, callback) {
    if (trace) trace("stat", null, path);
    root.getFile(path, {create: false}, function (fileEntry) {
      fileEntry.getMetadata(function (metaData) {
        var mtime = metaData.modificationTime / 1000;
        var mseconds = Math.floor(mtime);
        var mtime = [mseconds, Math.floor((mtime - mseconds) * 1000000000)];
        callback(null, {
          ctime: mtime,  // Not available on this platform
          mtime: mtime,
          dev: 0,        // Not available on this platform
          ino: 0,        // Not available on this platform
          mode: 0100644, // Not supported on this platform
          uid: 0,        // Not available on this platform
          gid: 0,        // Not available on this platform
          size: metaData.size
        });
      }, callback);
    }, callback);
  }

  function read(path, encoding, callback) {
    if (typeof encoding === "function") {
      callback = encoding;
      encoding = undefined;
    }
    if (trace) trace("read", null, path);
    root.getFile(path, {}, function (fileEntry) {
      fileEntry.file(function(file) {
        var reader = new FileReader();
        reader.onloadend = function (evt) {
          var value = this.result;
          if (!encoding) {
            value = new Uint8Array(value);
          }
          callback(null, value);
        };
        if (!encoding) {
          return reader.readAsArrayBuffer(file);
        }
        if (encoding === "binary") {
          return reader.readAsBinaryString(file);
        }
        return reader.readAsText(file, encoding);
      }, callback);
    }, callback);
  }

  function write(path, value, mode, callback) {
    if (typeof mode === "function") {
      callback = mode;
    }
    if (trace) trace("write", null, path);
    root.getFile(path, {create: true}, function (fileEntry) {
      fileEntry.createWriter(function(fileWriter) {
        fileWriter.onwriteend = function (evt) {
          callback();
        };
        fileWriter.onerror = function (evt) {
          callback(new Error("Write failed: " + evt.toString()));
        };
        fileWriter.write(new Blob([value]));
      }, callback);
    }, callback);
  }

  function unlink(path, callback) {
    if (trace) trace("unlink", null, path);
    root.getFile(path, {create: false}, function (fileEntry) {
      fileEntry.remove(function () {
        callback();
      }, callback);
    }, callback);
  }

  function readlink(path, callback) {
    if (trace) trace("readlink", null, path);
    callback(new Error("Symlinks are not supported in webfs"));
  }

  function symlink(path, value, callback) {
    if (trace) trace("symlink", null, path);
    callback(new Error("Symlinks are not supported in webfs"));
  }

  function readdir(path, callback) {
    if (trace) trace("readdir", null, path);
    root.getDirectory(path, {create: false}, function (dirEntry) {
      var dirReader = dirEntry.createReader();
      var entries = [];
      dirReader.readEntries(onRead, callback);
      function onRead(results) {
        if (results.length) {
          entries = entries.concat(toArray(results));
          dirReader.readEntries(onRead, callback);
        }
        callback(null, entries);
      }
    }, callback);
  }

  function rmdir(path, callback) {
    if (trace) trace("rmdir", null, path);
    root.getDirectory(path, {create: false}, function (dirEntry) {
      dirEntry.remove(function () {
        callback();
      }, callback);
    }, callback);
  }

  function mkdir(path, callback) {
    if (trace) trace("mkdir", null, path);
    if (path === ".") return callback();
    root.getDirectory(path, {create: true}, function (dirEntry) {
      callback();
    }, callback);
  }

  function rename(source, target, callback) {
    if (trace) trace("rename", null, path);
    root.getFile(source, {}, function (fileEntry) {
      var dirName = dirname(target);
      root.getDirectory(dirName, {}, function (dirEntry) {
        fileEntry.moveTo(dirEntry);
      }, callback);
    }, callback);
  }


};

function toArray(list) {
  return Array.prototype.slice.call(list || [], 0);
}

function wrapCallback(callback) {
  return function (err, data) {
    if (err) {
      callback(new Error(formatError(err)));
    }
    callback(null, data);
  };
}

function formatError(err) {
  switch (err.code) {
    case FileError.QUOTA_EXCEEDED_ERR:
           return 'QUOTA_EXCEEDED_ERR';
    case FileError.NOT_FOUND_ERR:
           return 'NOT_FOUND_ERR';
    case FileError.SECURITY_ERR:
           return 'SECURITY_ERR';
    case FileError.INVALID_MODIFICATION_ERR:
           return 'INVALID_MODIFICATION_ERR';
    case FileError.INVALID_STATE_ERR:
           return 'INVALID_STATE_ERR';
  };
  return 'Unknown Error';

}

function dirname(path) {
  if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
  var index = path.lastIndexOf("/");
  if (index === 0) return "/";
  if (index > 0) return path.substr(0, index);
  return ".";
}

function pathJoin(base, path) {
  if (base[base.length - 1] === "/") base = base.substr(0, base.length - 1);
  if (path[0] === "/") path = path.substr(1);
  return base + "/" + path;
}
